---
date:
  created: 2025-10-15

draft: true
---

# **üìÖ SAISON A Semaine 5 √âpisode 3 - Une Journ√©e en Pair-Programming**

## **üìö Notions du jour**

Aujourd‚Äôhui, j‚Äôai particip√© √† un **atelier en pair-programming** avec pour objectif de cr√©er une **application web d‚Äôardoise pixel art**, inspir√©e du style r√©tro de *Space Invaders*. Le d√©fi ? **Tout g√©n√©rer en JavaScript** : la grille de pixels, le formulaire de configuration, et m√™me la palette de couleurs. Nous avions seulement une maquette comme point de d√©part. Pas de code fourni, juste une id√©e √† concr√©tiser !

<!-- more -->

---

### **üìê √âtape Pr√©paratoire : D√©couper la Maquette**

Le matin, nous avons commenc√© par **analyser la maquette** pour identifier les √©l√©ments cl√©s :

1. **Un `<header>`** contenant un formulaire avec :
   + Un *input* pour d√©finir la **taille de la grille** (en nombre de pixels).
   + Un *input* pour d√©finir la **taille des pixels** (en pixels).
   + Un bouton pour valider et g√©n√©rer la grille.
2. **Un `<main>`** contenant :
   + La **grille de pixels** (notre ardoise).
   + Une **palette de couleurs** en bas, pour choisir la couleur des pixels.

**Action :** Nous avons cr√©√© une structure HTML basique et ajout√© un peu de CSS pour styliser les √©l√©ments (couleurs, tailles, etc.). L‚Äôid√©e √©tait de pr√©parer le terrain pour que JavaScript puisse prendre le relais.

```html title="invader.html - Body content"
<!DOCTYPE html>
<html lang="en">
<body>
  <header>
  </header>

  <main>
    <div id="grid"></div>
    <div class="palette"></div>
  </main>
  <script src="../js/app.js"></script>
</body>
</html>
```

```css title="style.css - base CSS"
:root {
    --pixel-color-grey-light: #D2DAE2;
    --pixel-border-grey-light: #808E9B;
    --pixel-color-grey-dark: #485460;
    --pixel-border-grey-dark: #1D262D;
    --bg-color-main: #665ACE;
    --bg-color-header: #3148AD;
}

header {
    background-color: var(--bg-color-header);
    height: 20dvh;
    display: flex;
    justify-content: center;
    align-items: center;
}

main {
    background-color: var(--bg-color-main);
    height: 80dvh;
    display: flex;
    justify-content: center;
    align-items: center;
}

#grid {
    display: grid;
    grid-template-rows: auto;
    width: auto;
    height: auto;
}

.pixel {
    background-color: var(--pixel-color-grey-light);
    border: 2px solid var(--pixel-border-grey-light);
    height: 50px;
    width: 50px;
}
```

---

### **üíª Cr√©ation de l‚ÄôApplication avec JavaScript**

#### **1Ô∏è‚É£ G√©n√©rer la Grille de Pixels**

**Objectif :** G√©n√©rer une grille dynamique en fonction de la taille choisie par l‚Äôutilisateur.

**Premi√®re approche :** Nous avons commenc√© par un `prompt()` pour demander la taille de la grille, en fixant la taille des pixels √† `50px` pour les tests.

```javascript title="app.js - Grid generation"
// Get #grid Object
const grid = document.getElementById("grid");
// Initial test with a prompt
const userInput = Number(prompt("Taille de la grille ?"));

// Use the grid-template-columns CSS property to create the grid
grid.style.gridTemplateColumns = `repeat(${userInput}, 1fr)`;
// Generate the grid
for (let round = 0; round < userInput * userInput; round++) {
  const pixel = document.createElement("div"); // Create a pixel element
  pixel.classList.add("pixel"); // Add .pixel class to the pixel element
  grid.appendChild(pixel); // Append pixel element into #grid element
}
```

??? success "**R√©sultat :** Une grille de pixels gris clair, pr√™te √† √™tre color√©e !"

    ![R√©sultat d'affichage de la grille dans le navigateur](../../assets/sa05E03/images/invaders_step1.png)

---

#### **2Ô∏è‚É£ Rendre les Pixels Cliquables**

**Objectif :** Changer la couleur d‚Äôun pixel au clic (noir par d√©faut).

**Solution :** Nous avons pens√© √† cr√©er une classe `dark` afin de l'ajouter √† un pixel lorsque celui-ci est *cliqu√©*. Si un pixel poss√®de la classe `dark`, alors il prend la couleur *noir*. En cherchant dans la documentation, nous avons trouver que nous pouvions utiliser un `addEventListener` avec la m√©thode `toggle()` de l'objet `classList`d'un *HTML DOM element* pour basculer entre les classes CSS.

```javascript
// Ajoute un √©couteur d'√©v√©nement √† chaque pixel
document.querySelectorAll(".pixel").forEach(pixel => {
  pixel.addEventListener("click", () => {
    pixel.classList.toggle("dark"); // Bascule entre gris et noir
  });
});
```

**CSS associ√© :**

```css
.pixel {
  background-color: #eee; /* Gris clair */
  border: 1px solid #ccc;
  display: inline-block;
}

.pixel.dark {
  background-color: #000; /* Noir */
}
```

**R√©sultat :** Une grille interactive o√π chaque clic inverse la couleur du pixel !

---

#### **3Ô∏è‚É£ Int√©grer le Formulaire**

**Objectif :** Remplacer le `prompt()` par un formulaire HTML pour configurer la grille.

**√âtapes :**

1. R√©cup√©rer les valeurs des *inputs* (taille de la grille et taille des pixels).
2. G√©n√©rer la grille en fonction de ces valeurs.

```javascript
// R√©cup√®re le formulaire
const form = document.querySelector("#grid-form");

// √âcoute la soumission du formulaire
form.addEventListener("submit", (event) => {
  event.preventDefault(); // Emp√™che le rechargement de la page

  // R√©cup√®re les valeurs des inputs
  const gridSize = document.querySelector("#grid-size").value;
  const pixelSize = document.querySelector("#pixel-size").value || 50; // Valeur par d√©faut : 50px

  // G√©n√®re la grille
  generateGrid(parseInt(gridSize), parseInt(pixelSize));
});

// Mise √† jour de la fonction generateGrid pour accepter la taille des pixels
function generateGrid(gridSize, pixelSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = "";
  gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;

  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey");
    pixel.style.width = `${pixelSize}px`;
    pixel.style.height = `${pixelSize}px`;
    gridContainer.appendChild(pixel);
  }

  // R√©applique les √©couteurs d'√©v√©nements
  document.querySelectorAll(".pixel").forEach(pixel => {
    pixel.addEventListener("click", () => {
      pixel.classList.toggle("dark");
    });
  });
}
```

**R√©sultat :** Un formulaire fonctionnel qui g√©n√®re une grille personnalis√©e !

---

#### **4Ô∏è‚É£ Partie Bonus : Cr√©er la Palette de Couleurs**

**Objectif :** Ajouter une palette de couleurs pour modifier la couleur des pixels.

**√âtapes :**

1. Cr√©er la palette en JavaScript (une `<div>` par couleur).
2. Permettre √† l‚Äôutilisateur de s√©lectionner une couleur.
3. Appliquer la couleur s√©lectionn√©e aux pixels cliqu√©s.

**Code pour la palette :**

```javascript
// Tableau des couleurs disponibles
const colors = ["red", "blue", "green", "yellow", "purple"];

// G√©n√®re la palette
function generatePalette() {
  const palette = document.querySelector("#palette");
  colors.forEach(color => {
    const colorDot = document.createElement("div");
    colorDot.classList.add("color-dot", color);
    colorDot.style.backgroundColor = color;
    palette.appendChild(colorDot);

    // √âcouteur pour s√©lectionner une couleur
    colorDot.addEventListener("click", () => {
      colorDot.classList.toggle("color-selected");
    });
  });
}

// Appelle la fonction au chargement de la page
generatePalette();
```

**CSS pour la palette :**

```css
.color-dot {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  margin: 5px;
  display: inline-block;
  cursor: pointer;
  border: 2px solid transparent;
}

.color-dot.color-selected {
  border: 2px solid black;
  transform: scale(1.2); /* Agrandit la pastille s√©lectionn√©e */
}
```

**R√©sultat :** Une palette de couleurs cliquables, o√π chaque couleur peut √™tre s√©lectionn√©e.

---

#### **5Ô∏è‚É£ Lier la Palette aux Pixels**

**Objectif :** Changer la couleur des pixels en fonction de la couleur s√©lectionn√©e dans la palette.

**Solution :** Nous avons utilis√© `classList.item()` pour r√©cup√©rer la classe de la couleur s√©lectionn√©e et l‚Äôappliquer aux pixels.

```javascript
// Variable pour stocker la couleur s√©lectionn√©e
let selectedColor = "dark";

// Met √† jour la couleur s√©lectionn√©e
document.querySelectorAll(".color-dot").forEach(dot => {
  dot.addEventListener("click", () => {
    // D√©s√©lectionne toutes les pastilles
    document.querySelectorAll(".color-dot").forEach(d => {
      d.classList.remove("color-selected");
    });

    // S√©lectionne la pastille cliqu√©e
    dot.classList.add("color-selected");

    // Met √† jour la couleur s√©lectionn√©e
    selectedColor = dot.classList.item(1); // R√©cup√®re la classe de couleur (ex: "red")
  });
});

// Met √† jour l'√©couteur des pixels pour utiliser la couleur s√©lectionn√©e
document.querySelectorAll(".pixel").forEach(pixel => {
  pixel.addEventListener("click", () => {
    // Supprime toutes les classes de couleur
    pixel.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");

    // Ajoute la classe de la couleur s√©lectionn√©e
    pixel.classList.add(selectedColor);
  });
});
```

??? success "**R√©sultat final obtenu :** Les pixels prennent la couleur s√©lectionn√©e dans la palette !"

    ![d√©mo du rendu final du challenge du jour](../../assets/sa05E03/images/invaders_final_result.gif)

---

### **üé® Am√©liorations et D√©fis**

**Probl√®me rencontr√© :** Derni√®re chose que nous avons pas r√©ussi √† faire et qu'il faudrait optimiser. Lorsque l'on clique sur une couleur pour la s√©lectionner il faudrait que celle-ci devienne s√©lectionn√©e et que toutes les autres couleurs ne soient plus s√©lectionn√©es. Le comportement actuel est que lorsqu'on clique sur une couleur, les autres couleurs restent s√©lectionn√©es si elles ont d√©j√† √©t√© s√©lectionn√©es avant. Ce qui fait que l'on peut s√©lectionner toutes les couleurs en m√™me temps.  
Il faut cliquer √† nouveau sur une couleur d√©j√† s√©lectionn√©e pour la d√©-s√©lectionner gr√¢ce √† `toggle()`. En l'√©tat pour pouvoir changer la couleur des pixels il faut s√©lectionner une seule couleur et d√©-s√©lectionner manuellement les autres couleurs afin de n'avoir qu'une seule couleur s√©lectionn√©e dans la **palette**. Ensuite on peut cliquer sur les pixels afin de changer leur couleur.

**Solution partielle :** Nous avons ajout√© une logique pour **d√©s√©lectionner toutes les pastilles** avant d‚Äôen s√©lectionner une nouvelle. Cependant, il reste √† optimiser ce comportement pour une exp√©rience plus fluide.

---

### **üí° Ce Que J‚Äôai Appris Aujourd‚Äôhui**

+ **Le pair programming est puissant** : Travailler √† deux permet de **r√©soudre des probl√®mes plus rapidement** et d‚Äôapprendre des approches diff√©rentes.
+ **La documentation est une alli√©e** : Sans elle, nous n‚Äôaurions pas trouv√© `classList.item()` ou `toggle()`.
+ **Les petites victoires comptent** : Chaque √©tape franchie (m√™me minuscule) est une avanc√©e !
+ **L‚Äôimportance des tests** : Tester chaque fonctionnalit√© au fur et √† mesure √©vite les bugs cumulatifs.
