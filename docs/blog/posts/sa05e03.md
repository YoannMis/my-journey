---
date:
  created: 2025-10-15

draft: true
---

# **📅 SAISON A Semaine 5 Épisode 3 - Une Journée en Pair-Programming**

## **📚 Notions du jour**

Aujourd’hui, j’ai participé à un **atelier en pair-programming** avec un objectif ambitieux : créer une **application web d’ardoise pixel art**, inspirée du style rétro de *Space Invaders*. Le défi ? **Tout générer en JavaScript** : la grille de pixels, le formulaire de configuration, et même la palette de couleurs. Nous avions seulement une maquette comme point de départ. Pas de code fourni, juste une idée à concrétiser !

<!-- more -->

---

### **📐 Étape Préparatoire : Découper la Maquette**

Le matin, nous avons commencé par **analyser la maquette** pour identifier les éléments clés :

1. **Un `<header>`** contenant un formulaire avec :
   - Un *input* pour définir la **taille de la grille** (nombre de pixels).
   - Un *input* pour définir la **taille des pixels** (en pixels, bien sûr !).
   - Un bouton pour valider et générer la grille.
2. **Un `<main>`** contenant :
   - La **grille de pixels** (notre ardoise).
   - Une **palette de couleurs** en bas, pour choisir la couleur des pixels.

**Action :** Nous avons créé une structure HTML basique et ajouté un peu de CSS pour styliser les éléments (couleurs, tailles, etc.). L’idée était de préparer le terrain pour que JavaScript puisse prendre le relais.

---

### **💻 Création de l’Application avec JavaScript**

#### **1️⃣ Générer la Grille de Pixels**
**Objectif :** Créer une grille dynamique en fonction de la taille choisie par l’utilisateur.

**Première approche :** Nous avons commencé par un `prompt` pour demander la taille de la grille, en fixant la taille des pixels à `50px` pour les tests.

```javascript
// Fonction pour générer la grille
function generateGrid(gridSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = ""; // Nettoie la grille existante

  // Crée les pixels
  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey"); // Classe "grey" pour la couleur par défaut
    pixel.style.width = "50px";
    pixel.style.height = "50px";
    gridContainer.appendChild(pixel);
  }
}

// Test initial avec un prompt
const gridSize = prompt("Entrez la taille de la grille (ex: 16 pour 16x16) :");
generateGrid(parseInt(gridSize));
```

**Résultat :** Une grille de pixels gris clair, prête à être colorée !

---

#### **2️⃣ Rendre les Pixels Cliquables**
**Objectif :** Changer la couleur d’un pixel au clic (noir par défaut).

**Solution :** Nous avons utilisé `addEventListener` et la méthode `toggle()` pour basculer entre les classes CSS.

```javascript
// Ajoute un écouteur d'événement à chaque pixel
document.querySelectorAll(".pixel").forEach(pixel => {
  pixel.addEventListener("click", () => {
    pixel.classList.toggle("dark"); // Bascule entre gris et noir
  });
});
```

**CSS associé :**
```css
.pixel {
  background-color: #eee; /* Gris clair */
  border: 1px solid #ccc;
  display: inline-block;
}

.pixel.dark {
  background-color: #000; /* Noir */
}
```

**Résultat :** Une grille interactive où chaque clic inverse la couleur du pixel !

---

#### **3️⃣ Intégrer le Formulaire**
**Objectif :** Remplacer le `prompt` par un formulaire HTML pour configurer la grille.

**Étapes :**
1. Récupérer les valeurs des *inputs* (taille de la grille et taille des pixels).
2. Générer la grille en fonction de ces valeurs.

```javascript
// Récupère le formulaire
const form = document.querySelector("#grid-form");

// Écoute la soumission du formulaire
form.addEventListener("submit", (event) => {
  event.preventDefault(); // Empêche le rechargement de la page

  // Récupère les valeurs des inputs
  const gridSize = document.querySelector("#grid-size").value;
  const pixelSize = document.querySelector("#pixel-size").value || 50; // Valeur par défaut : 50px

  // Génère la grille
  generateGrid(parseInt(gridSize), parseInt(pixelSize));
});

// Mise à jour de la fonction generateGrid pour accepter la taille des pixels
function generateGrid(gridSize, pixelSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = "";
  gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;

  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey");
    pixel.style.width = `${pixelSize}px`;
    pixel.style.height = `${pixelSize}px`;
    gridContainer.appendChild(pixel);
  }

  // Réapplique les écouteurs d'événements
  document.querySelectorAll(".pixel").forEach(pixel => {
    pixel.addEventListener("click", () => {
      pixel.classList.toggle("dark");
    });
  });
}
```

**Résultat :** Un formulaire fonctionnel qui génère une grille personnalisée !

---

#### **4️⃣ Créer la Palette de Couleurs**
**Objectif :** Ajouter une palette de couleurs pour modifier la couleur des pixels.

**Étapes :**
1. Créer la palette en JavaScript (une `<div>` par couleur).
2. Permettre à l’utilisateur de sélectionner une couleur.
3. Appliquer la couleur sélectionnée aux pixels cliqués.

**Code pour la palette :**
```javascript
// Tableau des couleurs disponibles
const colors = ["red", "blue", "green", "yellow", "purple"];

// Génère la palette
function generatePalette() {
  const palette = document.querySelector("#palette");
  colors.forEach(color => {
    const colorDot = document.createElement("div");
    colorDot.classList.add("color-dot", color);
    colorDot.style.backgroundColor = color;
    palette.appendChild(colorDot);

    // Écouteur pour sélectionner une couleur
    colorDot.addEventListener("click", () => {
      colorDot.classList.toggle("color-selected");
    });
  });
}

// Appelle la fonction au chargement de la page
generatePalette();
```

**CSS pour la palette :**
```css
.color-dot {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  margin: 5px;
  display: inline-block;
  cursor: pointer;
  border: 2px solid transparent;
}

.color-dot.color-selected {
  border: 2px solid black;
  transform: scale(1.2); /* Agrandit la pastille sélectionnée */
}
```

**Résultat :** Une palette de couleurs cliquables, où chaque couleur peut être sélectionnée.

---

#### **5️⃣ Lier la Palette aux Pixels**
**Objectif :** Changer la couleur des pixels en fonction de la couleur sélectionnée dans la palette.

**Solution :** Nous avons utilisé `classList.item()` pour récupérer la classe de la couleur sélectionnée et l’appliquer aux pixels.

```javascript
// Variable pour stocker la couleur sélectionnée
let selectedColor = "dark";

// Met à jour la couleur sélectionnée
document.querySelectorAll(".color-dot").forEach(dot => {
  dot.addEventListener("click", () => {
    // Désélectionne toutes les pastilles
    document.querySelectorAll(".color-dot").forEach(d => {
      d.classList.remove("color-selected");
    });

    // Sélectionne la pastille cliquée
    dot.classList.add("color-selected");

    // Met à jour la couleur sélectionnée
    selectedColor = dot.classList.item(1); // Récupère la classe de couleur (ex: "red")
  });
});

// Met à jour l'écouteur des pixels pour utiliser la couleur sélectionnée
document.querySelectorAll(".pixel").forEach(pixel => {
  pixel.addEventListener("click", () => {
    // Supprime toutes les classes de couleur
    pixel.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");

    // Ajoute la classe de la couleur sélectionnée
    pixel.classList.add(selectedColor);
  });
});
```

**Résultat :** Les pixels prennent la couleur sélectionnée dans la palette !

---

### **🎨 Partie Bonus : Améliorations et Défis**
**Problème rencontré :** Plusieurs couleurs pouvaient être sélectionnées en même temps dans la palette, ce qui n’était pas l’effet souhaité.

**Solution partielle :** Nous avons ajouté une logique pour **désélectionner toutes les pastilles** avant d’en sélectionner une nouvelle. Cependant, il reste à optimiser ce comportement pour une expérience plus fluide.

```javascript
// Dans l'écouteur de clic des pastilles :
document.querySelectorAll(".color-dot").forEach(dot => {
  dot.addEventListener("click", () => {
    // Désélectionne toutes les pastilles
    document.querySelectorAll(".color-dot").forEach(d => {
      d.classList.remove("color-selected");
    });

    // Sélectionne uniquement la pastille cliquée
    dot.classList.add("color-selected");
    selectedColor = dot.classList.item(1);
  });
});
```

---

### **💡 Ce Que J’ai Appris Aujourd’hui**
- **Le pair programming est puissant** : Travailler à deux permet de **résoudre des problèmes plus rapidement** et d’apprendre des approches différentes.
- **La documentation est une alliée** : Sans elle, nous n’aurions pas trouvé `classList.item()` ou `toggle()`.
- **Les petites victoires comptent** : Chaque étape franchie (même minuscule) est une avancée !
- **L’importance des tests** : Tester chaque fonctionnalité au fur et à mesure évite les bugs cumulatifs.

---
### **🚀 Prochaine Étape**
Demain, nous allons **optimiser la palette de couleurs** pour qu’une seule couleur puisse être sélectionnée à la fois, et peut-être ajouter un **bouton pour effacer la grille** ou **sauvegarder les dessins**.

**Et vous, avez-vous déjà fait du pair programming ? Quels sont vos retours d’expérience ?** 😊