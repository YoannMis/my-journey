---
date:
  created: 2025-10-15

draft: true
---

# **ğŸ“… SAISON A Semaine 5 Ã‰pisode 3 - Une JournÃ©e en Pair-Programming**

## **ğŸ“š Notions du jour**

Aujourdâ€™hui, jâ€™ai participÃ© Ã  un **atelier en pair-programming** avec un objectif ambitieux : crÃ©er une **application web dâ€™ardoise pixel art**, inspirÃ©e du style rÃ©tro de *Space Invaders*. Le dÃ©fi ? **Tout gÃ©nÃ©rer en JavaScript** : la grille de pixels, le formulaire de configuration, et mÃªme la palette de couleurs. Nous avions seulement une maquette comme point de dÃ©part. Pas de code fourni, juste une idÃ©e Ã  concrÃ©tiser !

<!-- more -->

---

### **ğŸ“ Ã‰tape PrÃ©paratoire : DÃ©couper la Maquette**

Le matin, nous avons commencÃ© par **analyser la maquette** pour identifier les Ã©lÃ©ments clÃ©s :

1. **Un `<header>`** contenant un formulaire avec :
   - Un *input* pour dÃ©finir la **taille de la grille** (nombre de pixels).
   - Un *input* pour dÃ©finir la **taille des pixels** (en pixels, bien sÃ»r !).
   - Un bouton pour valider et gÃ©nÃ©rer la grille.
2. **Un `<main>`** contenant :
   - La **grille de pixels** (notre ardoise).
   - Une **palette de couleurs** en bas, pour choisir la couleur des pixels.

**Action :** Nous avons crÃ©Ã© une structure HTML basique et ajoutÃ© un peu de CSS pour styliser les Ã©lÃ©ments (couleurs, tailles, etc.). Lâ€™idÃ©e Ã©tait de prÃ©parer le terrain pour que JavaScript puisse prendre le relais.

---

### **ğŸ’» CrÃ©ation de lâ€™Application avec JavaScript**

#### **1ï¸âƒ£ GÃ©nÃ©rer la Grille de Pixels**
**Objectif :** CrÃ©er une grille dynamique en fonction de la taille choisie par lâ€™utilisateur.

**PremiÃ¨re approche :** Nous avons commencÃ© par un `prompt` pour demander la taille de la grille, en fixant la taille des pixels Ã  `50px` pour les tests.

```javascript
// Fonction pour gÃ©nÃ©rer la grille
function generateGrid(gridSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = ""; // Nettoie la grille existante

  // CrÃ©e les pixels
  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey"); // Classe "grey" pour la couleur par dÃ©faut
    pixel.style.width = "50px";
    pixel.style.height = "50px";
    gridContainer.appendChild(pixel);
  }
}

// Test initial avec un prompt
const gridSize = prompt("Entrez la taille de la grille (ex: 16 pour 16x16) :");
generateGrid(parseInt(gridSize));
```

**RÃ©sultat :** Une grille de pixels gris clair, prÃªte Ã  Ãªtre colorÃ©e !

---

#### **2ï¸âƒ£ Rendre les Pixels Cliquables**
**Objectif :** Changer la couleur dâ€™un pixel au clic (noir par dÃ©faut).

**Solution :** Nous avons utilisÃ© `addEventListener` et la mÃ©thode `toggle()` pour basculer entre les classes CSS.

```javascript
// Ajoute un Ã©couteur d'Ã©vÃ©nement Ã  chaque pixel
document.querySelectorAll(".pixel").forEach(pixel => {
  pixel.addEventListener("click", () => {
    pixel.classList.toggle("dark"); // Bascule entre gris et noir
  });
});
```

**CSS associÃ© :**
```css
.pixel {
  background-color: #eee; /* Gris clair */
  border: 1px solid #ccc;
  display: inline-block;
}

.pixel.dark {
  background-color: #000; /* Noir */
}
```

**RÃ©sultat :** Une grille interactive oÃ¹ chaque clic inverse la couleur du pixel !

---

#### **3ï¸âƒ£ IntÃ©grer le Formulaire**
**Objectif :** Remplacer le `prompt` par un formulaire HTML pour configurer la grille.

**Ã‰tapes :**
1. RÃ©cupÃ©rer les valeurs des *inputs* (taille de la grille et taille des pixels).
2. GÃ©nÃ©rer la grille en fonction de ces valeurs.

```javascript
// RÃ©cupÃ¨re le formulaire
const form = document.querySelector("#grid-form");

// Ã‰coute la soumission du formulaire
form.addEventListener("submit", (event) => {
  event.preventDefault(); // EmpÃªche le rechargement de la page

  // RÃ©cupÃ¨re les valeurs des inputs
  const gridSize = document.querySelector("#grid-size").value;
  const pixelSize = document.querySelector("#pixel-size").value || 50; // Valeur par dÃ©faut : 50px

  // GÃ©nÃ¨re la grille
  generateGrid(parseInt(gridSize), parseInt(pixelSize));
});

// Mise Ã  jour de la fonction generateGrid pour accepter la taille des pixels
function generateGrid(gridSize, pixelSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = "";
  gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;

  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey");
    pixel.style.width = `${pixelSize}px`;
    pixel.style.height = `${pixelSize}px`;
    gridContainer.appendChild(pixel);
  }

  // RÃ©applique les Ã©couteurs d'Ã©vÃ©nements
  document.querySelectorAll(".pixel").forEach(pixel => {
    pixel.addEventListener("click", () => {
      pixel.classList.toggle("dark");
    });
  });
}
```

**RÃ©sultat :** Un formulaire fonctionnel qui gÃ©nÃ¨re une grille personnalisÃ©e !

---

#### **4ï¸âƒ£ CrÃ©er la Palette de Couleurs**
**Objectif :** Ajouter une palette de couleurs pour modifier la couleur des pixels.

**Ã‰tapes :**
1. CrÃ©er la palette en JavaScript (une `<div>` par couleur).
2. Permettre Ã  lâ€™utilisateur de sÃ©lectionner une couleur.
3. Appliquer la couleur sÃ©lectionnÃ©e aux pixels cliquÃ©s.

**Code pour la palette :**
```javascript
// Tableau des couleurs disponibles
const colors = ["red", "blue", "green", "yellow", "purple"];

// GÃ©nÃ¨re la palette
function generatePalette() {
  const palette = document.querySelector("#palette");
  colors.forEach(color => {
    const colorDot = document.createElement("div");
    colorDot.classList.add("color-dot", color);
    colorDot.style.backgroundColor = color;
    palette.appendChild(colorDot);

    // Ã‰couteur pour sÃ©lectionner une couleur
    colorDot.addEventListener("click", () => {
      colorDot.classList.toggle("color-selected");
    });
  });
}

// Appelle la fonction au chargement de la page
generatePalette();
```

**CSS pour la palette :**
```css
.color-dot {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  margin: 5px;
  display: inline-block;
  cursor: pointer;
  border: 2px solid transparent;
}

.color-dot.color-selected {
  border: 2px solid black;
  transform: scale(1.2); /* Agrandit la pastille sÃ©lectionnÃ©e */
}
```

**RÃ©sultat :** Une palette de couleurs cliquables, oÃ¹ chaque couleur peut Ãªtre sÃ©lectionnÃ©e.

---

#### **5ï¸âƒ£ Lier la Palette aux Pixels**
**Objectif :** Changer la couleur des pixels en fonction de la couleur sÃ©lectionnÃ©e dans la palette.

**Solution :** Nous avons utilisÃ© `classList.item()` pour rÃ©cupÃ©rer la classe de la couleur sÃ©lectionnÃ©e et lâ€™appliquer aux pixels.

```javascript
// Variable pour stocker la couleur sÃ©lectionnÃ©e
let selectedColor = "dark";

// Met Ã  jour la couleur sÃ©lectionnÃ©e
document.querySelectorAll(".color-dot").forEach(dot => {
  dot.addEventListener("click", () => {
    // DÃ©sÃ©lectionne toutes les pastilles
    document.querySelectorAll(".color-dot").forEach(d => {
      d.classList.remove("color-selected");
    });

    // SÃ©lectionne la pastille cliquÃ©e
    dot.classList.add("color-selected");

    // Met Ã  jour la couleur sÃ©lectionnÃ©e
    selectedColor = dot.classList.item(1); // RÃ©cupÃ¨re la classe de couleur (ex: "red")
  });
});

// Met Ã  jour l'Ã©couteur des pixels pour utiliser la couleur sÃ©lectionnÃ©e
document.querySelectorAll(".pixel").forEach(pixel => {
  pixel.addEventListener("click", () => {
    // Supprime toutes les classes de couleur
    pixel.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");

    // Ajoute la classe de la couleur sÃ©lectionnÃ©e
    pixel.classList.add(selectedColor);
  });
});
```

**RÃ©sultat :** Les pixels prennent la couleur sÃ©lectionnÃ©e dans la palette !

---

### **ğŸ¨ Partie Bonus : AmÃ©liorations et DÃ©fis**
**ProblÃ¨me rencontrÃ© :** Plusieurs couleurs pouvaient Ãªtre sÃ©lectionnÃ©es en mÃªme temps dans la palette, ce qui nâ€™Ã©tait pas lâ€™effet souhaitÃ©.

**Solution partielle :** Nous avons ajoutÃ© une logique pour **dÃ©sÃ©lectionner toutes les pastilles** avant dâ€™en sÃ©lectionner une nouvelle. Cependant, il reste Ã  optimiser ce comportement pour une expÃ©rience plus fluide.

```javascript
// Dans l'Ã©couteur de clic des pastilles :
document.querySelectorAll(".color-dot").forEach(dot => {
  dot.addEventListener("click", () => {
    // DÃ©sÃ©lectionne toutes les pastilles
    document.querySelectorAll(".color-dot").forEach(d => {
      d.classList.remove("color-selected");
    });

    // SÃ©lectionne uniquement la pastille cliquÃ©e
    dot.classList.add("color-selected");
    selectedColor = dot.classList.item(1);
  });
});
```

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris Aujourdâ€™hui**
- **Le pair programming est puissant** : Travailler Ã  deux permet de **rÃ©soudre des problÃ¨mes plus rapidement** et dâ€™apprendre des approches diffÃ©rentes.
- **La documentation est une alliÃ©e** : Sans elle, nous nâ€™aurions pas trouvÃ© `classList.item()` ou `toggle()`.
- **Les petites victoires comptent** : Chaque Ã©tape franchie (mÃªme minuscule) est une avancÃ©e !
- **Lâ€™importance des tests** : Tester chaque fonctionnalitÃ© au fur et Ã  mesure Ã©vite les bugs cumulatifs.

---
### **ğŸš€ Prochaine Ã‰tape**
Demain, nous allons **optimiser la palette de couleurs** pour quâ€™une seule couleur puisse Ãªtre sÃ©lectionnÃ©e Ã  la fois, et peut-Ãªtre ajouter un **bouton pour effacer la grille** ou **sauvegarder les dessins**.

**Et vous, avez-vous dÃ©jÃ  fait du pair programming ? Quels sont vos retours dâ€™expÃ©rience ?** ğŸ˜Š