---
date:
  created: 2025-10-21
  draft: true
---

# **ğŸ“… SAISON A Semaine 6 Ã‰pisode 2 - RÃ©activitÃ© Svelte et gestion des Ã©vÃ©nements**

## **ğŸ“š Notions du jour**

+ RÃ©activitÃ© avec la rune `$state()`
+ Ã‰vÃ©nements avec `on...`
+ Formulaires et binding avec `bind:`

<!-- more -->

---

### **âœ¨ La RÃ©activitÃ© avec `$state()` : Des Variables qui Sâ€™actualisent Toutes Seules !**

Aujourdâ€™hui, jâ€™ai dÃ©couvert lâ€™un des **super-pouvoirs de Svelte** : **la rÃ©activitÃ©**. En JavaScript natif, pour mettre Ã  jour lâ€™interface quand une variable change, il faut souvent **manipuler le DOM manuellement** (ex: `document.querySelector(...).textContent = nouvelleValeur`). Avec Svelte, câ€™est **automatique** grÃ¢ce Ã  la rune `$state()`.

#### **ğŸ”§ Comment Ã‡a Marche ?**

La rune `$state()` permet de dÃ©clarer une variable **rÃ©active** : dÃ¨s quâ€™elle est modifiÃ©e, Svelte met Ã  jour le DOM **sans que jâ€™aie Ã  le faire moi-mÃªme**.

**Exemple :**

```svelte
<script>
  // DÃ©clare une variable rÃ©active avec $state
  let count = $state(0);

  // Fonction pour incrÃ©menter le compteur
  function increment() {
    count += 1;  // Svelte met Ã  jour le DOM automatiquement !
  }
</script>

<!-- Le DOM est mis Ã  jour Ã  chaque changement de `count` -->
<button on:click={increment}>
  Clics : {count}
</button>
```
**RÃ©sultat :** Le bouton affiche le nombre de clics, et le compteur sâ€™incrÃ©mente **sans rafraÃ®chir la page**.

---
#### **ğŸ’¡ Pourquoi Câ€™est GÃ©nial ?**
- **Moins de code** : Pas besoin dâ€™Ã©crire des Ã©couteurs dâ€™Ã©vÃ©nements pour mettre Ã  jour le DOM.
- **Plus lisible** : La logique est claire et concentrÃ©e dans le composant.
- **Performant** : Svelte optimise les mises Ã  jour du DOM pour Ã©viter les calculs inutiles.

---

### **ğŸ¯ Gestion des Ã‰vÃ©nements avec `on:`**
En HTML natif, on utilise `addEventListener` pour Ã©couter les Ã©vÃ©nements (clics, soumissions de formulaire, etc.). Avec Svelte, câ€™est encore plus simple grÃ¢ce Ã  la syntaxe `on:event`.

#### **ğŸ“– Exemples dâ€™Utilisation**
1. **Ã‰couter un clic :**
   ```svelte
   <button on:click={() => alert("Bouton cliquÃ© !")}>
     Cliquez-moi !
   </button>
   ```

2. **Ã‰couter la soumission dâ€™un formulaire :**
   ```svelte
   <form on:submit|preventDefault={(e) => {
     alert("Formulaire soumis !");
   }}>
     <input type="text" />
     <button type="submit">Envoyer</button>
   </form>
   ```
   - `|preventDefault` empÃªche le comportement par dÃ©faut (ex: rechargement de la page).

3. **Ã‰couter les changements dâ€™un input :**
   ```svelte
   <input
     type="text"
     on:input={(e) => {
       console.log("Valeur saisie :", e.target.value);
     }}
   />
   ```

---
#### **ğŸ’¡ Avantages de `on:`**
- **Syntax concise** : Pas besoin de `addEventListener` ou de `querySelector`.
- **IntÃ©gration naturelle** avec les composants Svelte.
- **Modificateurs pratiques** comme `|preventDefault`, `|stopPropagation`, etc.

---

### **ğŸ“ Formulaires et Binding avec `bind:` : La Magie des DonnÃ©es LiÃ©es**
La vraie rÃ©volution de la journÃ©e : **le *two-way data binding*** avec `bind:`. Cette syntaxe permet de **lier directement une variable Ã  un champ de formulaire**. Plus besoin de gÃ©rer manuellement les changements avec `on:input` ou `e.target.value` !

#### **ğŸ“– Exemples Concrets**
1. **Lier un input texte Ã  une variable :**
   ```svelte
   <script>
     let name = $state("");  // Variable rÃ©active
   </script>

   <input type="text" bind:value={name} />
   <p>Bonjour, {name} !</p>
   ```
   - DÃ¨s que lâ€™utilisateur tape dans lâ€™input, la variable `name` est mise Ã  jour, et le paragraphe sâ€™affiche en temps rÃ©el.

2. **Lier une case Ã  cocher (`checkbox`) :**
   ```svelte
   <script>
     let isChecked = $state(false);
   </script>

   <input type="checkbox" bind:checked={isChecked} />
   <p>La case est {isChecked ? "cochÃ©e" : "dÃ©cochÃ©e"}.</p>
   ```

3. **Lier une liste dÃ©roulante (`select`) :**
   ```svelte
   <script>
     let selectedFruit = $state("pomme");
     const fruits = ["pomme", "banane", "orange"];
   </script>

   <select bind:value={selectedFruit}>
     {#each fruits as fruit}
       <option value={fruit}>{fruit}</option>
     {/each}
   </select>
   <p>Fruit sÃ©lectionnÃ© : {selectedFruit}</p>
   ```

4. **Lier un textarea :**
   ```svelte
   <script>
     let description = $state("");
   </script>

   <textarea bind:value={description}></textarea>
   <p>Description : {description}</p>
   ```

---
#### **ğŸ’¡ Pourquoi `bind:` est GÃ©nial ?**
- **Synchronisation automatique** : La variable et le champ de formulaire sont toujours synchronisÃ©s.
- **Moins de code** : Pas besoin dâ€™Ã©crire des gestionnaires dâ€™Ã©vÃ©nements pour chaque champ.
- **IntÃ©gration avec `$state()`** : Les variables liÃ©es sont rÃ©actives par dÃ©faut.

---

### **ğŸ§© Combiner Tout : Un Exemple Complet avec Formulaire RÃ©actif**
Voici un exemple complet dâ€™un **formulaire de crÃ©ation de recette** utilisant `$state()`, `on:`, et `bind:` :

```svelte
<script>
  // Variables rÃ©actives pour le formulaire
  let title = $state("");
  let ingredients = $state("");
  let isFavorite = $state(false);

  // Fonction pour soumettre le formulaire
  function handleSubmit() {
    alert(`Nouvelle recette : ${title}\nIngrÃ©dients : ${ingredients}\nFavorite : ${isFavorite}`);
    // Ici, on pourrait ajouter la recette Ã  un tableau ou l'envoyer Ã  une API
  }
</script>

<!-- Formulaire avec binding et gestion d'Ã©vÃ©nement -->
<form on:submit|preventDefault={handleSubmit}>
  <div>
    <label for="title">Titre de la recette :</label>
    <input type="text" id="title" bind:value={title} required />
  </div>

  <div>
    <label for="ingredients">IngrÃ©dients :</label>
    <textarea id="ingredients" bind:value={ingredients} required></textarea>
  </div>

  <div>
    <label>
      <input type="checkbox" bind:checked={isFavorite} />
      Recette favorite ?
    </label>
  </div>

  <button type="submit">Ajouter la recette</button>
</form>

<!-- Affichage en temps rÃ©el des donnÃ©es du formulaire -->
<div class="preview">
  <h2>AperÃ§u :</h2>
  <h3>{title || "Sans titre"}</h3>
  <p>{ingredients || "Aucun ingrÃ©dient"}</p>
  <p>Favorite : {isFavorite ? "â­ Oui" : "âŒ Non"}</p>
</div>

<!-- Styles CSS -->
<style>
  form {
    max-width: 400px;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 8px;
  }

  label, input, textarea {
    display: block;
    margin-bottom: 10px;
  }

  .preview {
    max-width: 400px;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #eee;
    border-radius: 8px;
    background: #f9f9f9;
  }
</style>
```

---
#### **ğŸ–¼ï¸ Rendu du Formulaire RÃ©actif**
*(InsÃ©rer ici une capture dâ€™Ã©cran du formulaire en action, avec lâ€™aperÃ§u qui se met Ã  jour en temps rÃ©el.)*

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris Aujourdâ€™hui**
1. **La rÃ©activitÃ© avec `$state()`** : Plus besoin de manipuler le DOM manuellement, Svelte sâ€™en charge !
2. **Les Ã©vÃ©nements avec `on:`** : Une syntaxe simple et intÃ©grÃ©e pour gÃ©rer les interactions utilisateur.
3. **Le *two-way data binding* avec `bind:`** : La synchronisation automatique entre les champs de formulaire et les variables est un **game-changer**.
4. **Combiner ces concepts** permet de crÃ©er des interfaces **dynamiques et rÃ©actives** avec trÃ¨s peu de code.

---
### **ğŸš€ Prochaine Ã‰tape**
Demain, nous allons :
- **Stocker les recettes** dans le `localStorage` pour les conserver entre les sessions.
- **Ajouter des fonctionnalitÃ©s dâ€™Ã©dition et de suppression** des recettes.
- **Explorer les *stores*** pour gÃ©rer lâ€™Ã©tat global de lâ€™application.

**Et vous, quelle est votre fonctionnalitÃ© prÃ©fÃ©rÃ©e en Svelte jusquâ€™Ã  prÃ©sent ?** ğŸ˜Š
*(Nâ€™hÃ©sitez pas Ã  partager vos retours ou astuces sur la rÃ©activitÃ© et les formulaires !)*