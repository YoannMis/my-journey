---
date:
  created: 2025-10-21
  draft: true
---

# **📅 SAISON A Semaine 6 Épisode 2 - Réactivité Svelte et gestion des événements**

## **📚 Notions du jour**

+ Réactivité avec la rune `$state()`
+ Événements avec `on...`
+ Formulaires et binding avec `bind:`

<!-- more -->

---

### **✨ La Réactivité avec `$state()` : Des Variables qui S’actualisent Toutes Seules !**

Aujourd’hui, j’ai découvert l’un des **super-pouvoirs de Svelte** : **la réactivité**. En JavaScript natif, pour mettre à jour l’interface quand une variable change, il faut souvent **manipuler le DOM manuellement** (ex: `document.querySelector(...).textContent = nouvelleValeur`). Avec Svelte, c’est **automatique** grâce à la rune `$state()`.

#### **🔧 Comment Ça Marche ?**

La rune `$state()` permet de déclarer une variable **réactive** : dès qu’elle est modifiée, Svelte met à jour le DOM **sans que j’aie à le faire moi-même**.

**Exemple :**

```svelte
<script>
  // Déclare une variable réactive avec $state
  let count = $state(0);

  // Fonction pour incrémenter le compteur
  function increment() {
    count += 1;  // Svelte met à jour le DOM automatiquement !
  }
</script>

<!-- Le DOM est mis à jour à chaque changement de `count` -->
<button on:click={increment}>
  Clics : {count}
</button>
```
**Résultat :** Le bouton affiche le nombre de clics, et le compteur s’incrémente **sans rafraîchir la page**.

---
#### **💡 Pourquoi C’est Génial ?**
- **Moins de code** : Pas besoin d’écrire des écouteurs d’événements pour mettre à jour le DOM.
- **Plus lisible** : La logique est claire et concentrée dans le composant.
- **Performant** : Svelte optimise les mises à jour du DOM pour éviter les calculs inutiles.

---

### **🎯 Gestion des Événements avec `on:`**
En HTML natif, on utilise `addEventListener` pour écouter les événements (clics, soumissions de formulaire, etc.). Avec Svelte, c’est encore plus simple grâce à la syntaxe `on:event`.

#### **📖 Exemples d’Utilisation**
1. **Écouter un clic :**
   ```svelte
   <button on:click={() => alert("Bouton cliqué !")}>
     Cliquez-moi !
   </button>
   ```

2. **Écouter la soumission d’un formulaire :**
   ```svelte
   <form on:submit|preventDefault={(e) => {
     alert("Formulaire soumis !");
   }}>
     <input type="text" />
     <button type="submit">Envoyer</button>
   </form>
   ```
   - `|preventDefault` empêche le comportement par défaut (ex: rechargement de la page).

3. **Écouter les changements d’un input :**
   ```svelte
   <input
     type="text"
     on:input={(e) => {
       console.log("Valeur saisie :", e.target.value);
     }}
   />
   ```

---
#### **💡 Avantages de `on:`**
- **Syntax concise** : Pas besoin de `addEventListener` ou de `querySelector`.
- **Intégration naturelle** avec les composants Svelte.
- **Modificateurs pratiques** comme `|preventDefault`, `|stopPropagation`, etc.

---

### **📝 Formulaires et Binding avec `bind:` : La Magie des Données Liées**
La vraie révolution de la journée : **le *two-way data binding*** avec `bind:`. Cette syntaxe permet de **lier directement une variable à un champ de formulaire**. Plus besoin de gérer manuellement les changements avec `on:input` ou `e.target.value` !

#### **📖 Exemples Concrets**
1. **Lier un input texte à une variable :**
   ```svelte
   <script>
     let name = $state("");  // Variable réactive
   </script>

   <input type="text" bind:value={name} />
   <p>Bonjour, {name} !</p>
   ```
   - Dès que l’utilisateur tape dans l’input, la variable `name` est mise à jour, et le paragraphe s’affiche en temps réel.

2. **Lier une case à cocher (`checkbox`) :**
   ```svelte
   <script>
     let isChecked = $state(false);
   </script>

   <input type="checkbox" bind:checked={isChecked} />
   <p>La case est {isChecked ? "cochée" : "décochée"}.</p>
   ```

3. **Lier une liste déroulante (`select`) :**
   ```svelte
   <script>
     let selectedFruit = $state("pomme");
     const fruits = ["pomme", "banane", "orange"];
   </script>

   <select bind:value={selectedFruit}>
     {#each fruits as fruit}
       <option value={fruit}>{fruit}</option>
     {/each}
   </select>
   <p>Fruit sélectionné : {selectedFruit}</p>
   ```

4. **Lier un textarea :**
   ```svelte
   <script>
     let description = $state("");
   </script>

   <textarea bind:value={description}></textarea>
   <p>Description : {description}</p>
   ```

---
#### **💡 Pourquoi `bind:` est Génial ?**
- **Synchronisation automatique** : La variable et le champ de formulaire sont toujours synchronisés.
- **Moins de code** : Pas besoin d’écrire des gestionnaires d’événements pour chaque champ.
- **Intégration avec `$state()`** : Les variables liées sont réactives par défaut.

---

### **🧩 Combiner Tout : Un Exemple Complet avec Formulaire Réactif**
Voici un exemple complet d’un **formulaire de création de recette** utilisant `$state()`, `on:`, et `bind:` :

```svelte
<script>
  // Variables réactives pour le formulaire
  let title = $state("");
  let ingredients = $state("");
  let isFavorite = $state(false);

  // Fonction pour soumettre le formulaire
  function handleSubmit() {
    alert(`Nouvelle recette : ${title}\nIngrédients : ${ingredients}\nFavorite : ${isFavorite}`);
    // Ici, on pourrait ajouter la recette à un tableau ou l'envoyer à une API
  }
</script>

<!-- Formulaire avec binding et gestion d'événement -->
<form on:submit|preventDefault={handleSubmit}>
  <div>
    <label for="title">Titre de la recette :</label>
    <input type="text" id="title" bind:value={title} required />
  </div>

  <div>
    <label for="ingredients">Ingrédients :</label>
    <textarea id="ingredients" bind:value={ingredients} required></textarea>
  </div>

  <div>
    <label>
      <input type="checkbox" bind:checked={isFavorite} />
      Recette favorite ?
    </label>
  </div>

  <button type="submit">Ajouter la recette</button>
</form>

<!-- Affichage en temps réel des données du formulaire -->
<div class="preview">
  <h2>Aperçu :</h2>
  <h3>{title || "Sans titre"}</h3>
  <p>{ingredients || "Aucun ingrédient"}</p>
  <p>Favorite : {isFavorite ? "⭐ Oui" : "❌ Non"}</p>
</div>

<!-- Styles CSS -->
<style>
  form {
    max-width: 400px;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 8px;
  }

  label, input, textarea {
    display: block;
    margin-bottom: 10px;
  }

  .preview {
    max-width: 400px;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #eee;
    border-radius: 8px;
    background: #f9f9f9;
  }
</style>
```

---
#### **🖼️ Rendu du Formulaire Réactif**
*(Insérer ici une capture d’écran du formulaire en action, avec l’aperçu qui se met à jour en temps réel.)*

---

### **💡 Ce Que J’ai Appris Aujourd’hui**
1. **La réactivité avec `$state()`** : Plus besoin de manipuler le DOM manuellement, Svelte s’en charge !
2. **Les événements avec `on:`** : Une syntaxe simple et intégrée pour gérer les interactions utilisateur.
3. **Le *two-way data binding* avec `bind:`** : La synchronisation automatique entre les champs de formulaire et les variables est un **game-changer**.
4. **Combiner ces concepts** permet de créer des interfaces **dynamiques et réactives** avec très peu de code.

---
### **🚀 Prochaine Étape**
Demain, nous allons :
- **Stocker les recettes** dans le `localStorage` pour les conserver entre les sessions.
- **Ajouter des fonctionnalités d’édition et de suppression** des recettes.
- **Explorer les *stores*** pour gérer l’état global de l’application.

**Et vous, quelle est votre fonctionnalité préférée en Svelte jusqu’à présent ?** 😊
*(N’hésitez pas à partager vos retours ou astuces sur la réactivité et les formulaires !)*