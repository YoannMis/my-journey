---
date:
  created: 2025-12-01

---

# **ğŸ“… SAISON B Semaine 5 Ã‰pisode 1 - DÃ©couverte de la Programmation OrientÃ©e Objet (POO) en JavaScript â€“ Classes, Encapsulation et ContrÃ´le dâ€™AccÃ¨s**

## **ğŸ“š Notions du jour**

Aujourd'hui nous avons aborbÃ© un paradigme important en programmation : la **Programmation OrientÃ©e Objet** (ou ***POO*** pour les intimes). C'est un concept que je connaissais dÃ©jÃ  avec le langage de programmation Python que je pratiquais avant de commencer ma formation. Cette fois-ci j'ai pu voir comment cela Ã©tait organisÃ© en JavaScript en commenÃ§ant par les fondamentaux.

Voici les notions aborbÃ©es durant cette journÃ©e :

+ Les limites du code procÃ©dural et lâ€™intÃ©rÃªt de la **POO**.
+ La syntaxe **`class`** pour dÃ©finir un Â« moule Â» Ã  objets.
+ Le **`constructor`** pour initialiser une nouvelle instance.
+ Lâ€™encapsulation pour protÃ©ger les donnÃ©es.
+ Les attributs privÃ©s avec le prÃ©fixe `#`.
+ Les ***getters*** et ***setters*** pour contrÃ´ler lâ€™accÃ¨s aux donnÃ©es.

<!-- more -->

---

### **ğŸ”„ Pourquoi la POO ? Les Limites du Code ProcÃ©dural**

Jusquâ€™Ã  prÃ©sent, jâ€™ai principalement Ã©crit du code **procÃ©dural** : des fonctions qui sâ€™enchaÃ®nent pour accomplir des tÃ¢ches. Cependant, Ã  mesure que les projets grandissent, ce style de programmation montre ses limites :

+ **Manque de structure** : Le code devient difficile Ã  organiser et Ã  maintenir.
+ **RÃ©pÃ©tition** : Les donnÃ©es et les fonctions qui les manipulent sont souvent sÃ©parÃ©es, ce qui conduit Ã  dupliquer du code.
+ **Faible rÃ©utilisabilitÃ©** : Difficile de rÃ©utiliser des morceaux de logique dans dâ€™autres parties du projet.

La **Programmation OrientÃ©e Objet (POO)** rÃ©sout ces problÃ¨mes en **regroupant les donnÃ©es et les comportements** dans des **objets**. Cela permet de :

âœ… **ModÃ©liser des entitÃ©s rÃ©elles** (ex. : un Ã©tudiant, une promotion).  
âœ… **Encapsuler les donnÃ©es** pour les protÃ©ger et contrÃ´ler leur accÃ¨s.  
âœ… **RÃ©utiliser du code** grÃ¢ce Ã  lâ€™hÃ©ritage et la composition.

---

### **ğŸ—ï¸ Les Classes : Des Moules pour CrÃ©er des Objets**

En JavaScript, une **classe** est comme un **moule** qui dÃ©finit la structure et le comportement des objets. Elle permet de crÃ©er des **instances** (objets concrets) avec des **attributs** (donnÃ©es) et des **mÃ©thodes** (fonctions).

#### **1ï¸âƒ£ DÃ©finir une Classe avec `class`**

```javascript
// Define a class to represent a Student
class Student {
  // The constructor initializes new instances
  constructor(firstName, lastName, age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
  }

  // Method to display student info
  getInfo() {
    return `${this.firstName} ${this.lastName}, ${this.age} years old`;
  }
}
```

**Explications :**

+ **`class Student`** : DÃ©finit une classe nommÃ©e `Student`.
+ **`constructor`** : MÃ©thode spÃ©ciale appelÃ©e lors de la crÃ©ation dâ€™une instance pour initialiser ses attributs.
+ **`this`** : Fait rÃ©fÃ©rence Ã  lâ€™instance courante de la classe.

---

#### **2ï¸âƒ£ CrÃ©er une Instance avec `new`**

```javascript
// Create a new student instance
const student1 = new Student('John', 'Doe', 20);
console.log(student1.getInfo()); // Output: "John Doe, 20 years old"
```

**RÃ©sultat :**

Un objet `student1` est crÃ©Ã© avec les attributs `firstName`, `lastName`, et `age`, ainsi que la mÃ©thode `getInfo()`.

---

### **ğŸ”’ Lâ€™Encapsulation : ProtÃ©ger les DonnÃ©es**

Lâ€™**encapsulation** est un principe clÃ© de la POO qui consiste Ã  :

+ **Cacher les dÃ©tails internes** dâ€™un objet.
+ **ContrÃ´ler lâ€™accÃ¨s** aux donnÃ©es via des mÃ©thodes (getters/setters).
+ **Ã‰viter les modifications accidentelles** des attributs.

#### **1ï¸âƒ£ Attributs PrivÃ©s avec `#`**

En JavaScript, on peut dÃ©clarer des **attributs privÃ©s** en utilisant le prÃ©fixe `#`. Ces attributs **ne sont accessibles quâ€™Ã  lâ€™intÃ©rieur de la classe**.

```javascript
class Student {
  // Private attributes
  #firstName;
  #lastName;
  #age;

  constructor(firstName, lastName, age) {
    this.#firstName = firstName;
    this.#lastName = lastName;
    this.#age = age;
  }

  // Public method to access private data
  getInfo() {
    return `${this.#firstName} ${this.#lastName}, ${this.#age} years old`;
  }

  // Attempting to access #firstName outside the class will throw an error
  // console.log(student1.#firstName); // SyntaxError: Private field '#firstName' must be declared in an enclosing class
}
```

**Avantages :**

+ **SÃ©curitÃ©** : Les attributs privÃ©s ne peuvent pas Ãªtre modifiÃ©s directement depuis lâ€™extÃ©rieur.
+ **ContrÃ´le** : Vous dÃ©cidez comment et quand les donnÃ©es sont accessibles ou modifiÃ©es.

---

#### **2ï¸âƒ£ Getters et Setters pour ContrÃ´ler lâ€™AccÃ¨s**

Les ***getters*** et ***setters*** permettent de **lire et modifier les attributs privÃ©s** de maniÃ¨re contrÃ´lÃ©e.

```javascript
class Student {
  #firstName;
  #lastName;
  #age;

  constructor(firstName, lastName, age) {
    this.#firstName = firstName;
    this.#lastName = lastName;
    this.#age = age;
  }

  // Getter for firstName
  get firstName() {
    return this.#firstName;
  }

  // Setter for firstName (with validation)
  set firstName(newFirstName) {
    if (typeof newFirstName === 'string' && newFirstName.length > 0) {
      this.#firstName = newFirstName;
    } else {
      console.error('First name must be a non-empty string');
    }
  }

  // Getter for age
  get age() {
    return this.#age;
  }

  // Setter for age (with validation)
  set age(newAge) {
    if (Number.isInteger(newAge) && newAge > 0) {
      this.#age = newAge;
    } else {
      console.error('Age must be a positive integer');
    }
  }
}

// Usage
const student1 = new Student('John', 'Doe', 20);
console.log(student1.firstName); // "John" (using getter)
student1.firstName = 'Jane';      // Valid update
student1.age = 25;                // Valid update
student1.age = -5;                // Error: "Age must be a positive integer"
```

**Explications :**

+ **`get firstName()`** : Permet dâ€™accÃ©der Ã  lâ€™attribut privÃ© `#firstName`.
+ **`set firstName(newFirstName)`** : Valide et met Ã  jour `#firstName` si la nouvelle valeur est valide.
+ **Validation** : Les setters peuvent inclure des rÃ¨gles pour garantir la cohÃ©rence des donnÃ©es.

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris Aujourdâ€™hui**

1. **Les classes** permettent de **crÃ©er des objets structurÃ©s** avec des attributs et des mÃ©thodes.
2. **Lâ€™encapsulation** protÃ¨ge les donnÃ©es en les rendant **privÃ©es** et en contrÃ´lant leur accÃ¨s via des **getters/setters**.
3. **Les attributs privÃ©s** (avec `#`) empÃªchent les modifications directes depuis lâ€™extÃ©rieur de la classe.
4. **Les getters/setters** permettent de **valider les donnÃ©es** avant de les modifier, garantissant ainsi leur intÃ©gritÃ©.
5. **La POO rend le code plus modulaire et rÃ©utilisable**, ce qui facilite la maintenance et lâ€™Ã©volution des projets.

---

## **âŒ¨ï¸ Challenge du jour : "Projet oCoffee" â€“ projet fil rouge**

---

### **â˜•ï¸ PrÃ©sentation du Challenge**

Cette semaine nous allons continuer Ã  travailler sur notre projet **oCoffee** rÃ©alisÃ© la semaine derniÃ¨re en autonomie. L'idÃ©e est de **refactoriser notre application** en utilisant la **POO**.  
Plus prÃ©cisÃ©ment, il sâ€™agissait de **remplacer les objets bruts** retournÃ©s par notre ***datamapper*** par des **instances de la classe `Coffee`** crÃ©Ã©e en cours, afin de pouvoir utiliser ses mÃ©thodes directement dans nos vues EJS.

---

### **ğŸ“ Structure du Projet (bac Ã  sable) RÃ©cupÃ©rÃ© pour le Challenge**

```bash
ğŸ“ocoffee/
â”‚
â”œâ”€â”€ ğŸ“node_modules/          # Folder generated by npm (do not version)
â”‚
â”œâ”€â”€ ğŸ“data/                            #Database folder
â”‚   â”œâ”€â”€ create_database.sql
â”‚   â””â”€â”€ README.md               # How to connect to DB documentation
â”‚
â”œâ”€â”€ ğŸ“database/             # Interactions with the database
â”‚   â”œâ”€â”€ main-datamapper.js       
â”‚   â””â”€â”€ database-client.js   # Connection to database    
â”‚
â”œâ”€â”€ ğŸ“docs/                  # Project specifications folder                  
â”‚   â”œâ”€â”€ ğŸ“damande-client/
â”‚   â”œâ”€â”€ ğŸ“integration/
â”‚   â””â”€â”€ ğŸ“recommandations/
â”‚
â”œâ”€â”€ ğŸ“public/                # Static files (CSS, JS, images)
â”‚   â”œâ”€â”€ ğŸ“css/               # Style sheets
â”‚   â”œâ”€â”€ ğŸ“images/            # Images for the site (logos, cafes, etc.)
â”‚   â””â”€â”€ ğŸ“js/                # Client-side JavaScript scripts
â”‚
â”œâ”€â”€ ğŸ“views/                # EJS views (templates)
â”‚     â”œâ”€â”€ ğŸ“partials/       # Reusable partials (header, footer)
â”‚     â””â”€â”€ ğŸ“pages/          # App pages
â”‚
â”œâ”€â”€ index.js                # Express app entry point
â”œâ”€â”€ router.js               # Express routes handler
â”œâ”€â”€ package.json            # Dependencies and npm scripts
â”œâ”€â”€ package-lock.json         
â”œâ”€â”€ .env.example            # Public environnement variables
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md               # Project documentation
```

### **ğŸ“Œ Ã‰tapes Ã  RÃ©aliser**

#### **1ï¸âƒ£ Importer la Classe `Coffee` dans le Datamapper**

**Objectif :** Importer la classe `Coffee` crÃ©Ã©e en cours pour pouvoir crÃ©er des instances Ã  partir des donnÃ©es de la base.

**Mon code :**

J'ai crÃ©Ã© un dossier `src/models/` oÃ¹ j'ai copiÃ© la classe `Coffee` crÃ©Ã©e en cours âŸ¹ `src/models/Coffee.js`.

Ensuite je l'importe dans `database/main-datamapper.js` :

```javascript title="database/main-datamapper.js"
import Coffee from "../src/models/Coffee.js";
```

---

#### **2ï¸âƒ£ Modifier la MÃ©thode `getLatestsProducts()`**

**Objectif :** Transformer les objets bruts retournÃ©s par la base de donnÃ©es en **instances de `Coffee`**.

**Mon code :**

Fichier d'origine :

```javascript title="database/main-datamapper.js" hl_lines="12-19"
// Import database client
import db from "./database-client.js";

const datamapper = {
  /**
   * Retrieves the 3 most recently added products (coffees) from the database.
   * @async
   * @function getLatestsProducts
   * @returns {Promise<Array>} A promise resolving to an array of objects representing the 3 most recently added coffees.
   */
  async getLatestsProducts() {
     // SQL query to select the 3 most recent coffees, ordered by creation date
    const result = await db.query(
      `SELECT * FROM coffee ORDER BY created_at DESC LIMIT 3`
    );
    const products = result.rows;
    return products;
  },
  // ... other methods...
};

export default datamapper;
```

Refactorisation :

```javascript title="database/main-datamapper.js" hl_lines="24-32"
// Import Coffee Class
import Coffee from "../src/models/Coffee.js";

const datamapper = {
  /**
   * Retrieves the 3 most recently added products (coffees) from the database
   * and maps them to Coffee model instances.
   * @async
   * @function getLatestsProducts
   * @returns {Promise<Array<Coffee>>} A promise resolving to an array of Coffee instances representing the 3 most recently added coffees.
   */
  async function getLatestsProducts() {
    // SQL query to select the 3 most recent coffees, ordered by creation date
    const query = `
      SELECT * FROM coffee
      ORDER BY created_at DESC
      LIMIT 3;
    `;
    // Execute the query and retrieve the result
    const result = await client.query(query);

    const products = result.rows;

    // Map each product row to a Coffee model instance
    const coffees = products.map(product => new Coffee({
          id: product.id,
          name: product.name,
          description: product.description,
          reference: product.reference,
          pricePerKg: product.price_per_kg,
          available: product.available,
        }));
    
    return coffees;
  },
  // ... other methods...
}
```

**Explications :**

+ **`result.rows.map(...)`** : Utilise la mÃ©thode `map()` pour transformer chaque objet brut en une instance de `Coffee`.
+ **`new Coffee(...)`** : CrÃ©e une nouvelle instance de `Coffee` avec les donnÃ©es de la base.

---

#### **3ï¸âƒ£ Utiliser les MÃ©thodes de `Coffee` dans la Vue `home.ejs`**

**Objectif :** Afficher le prix formatÃ© en utilisant la mÃ©thode `getFormattedPrice()` de la classe `Coffee`.

La classe Coffee Ã©tait fournie avec ses mÃ©thodes de classe. J'ai dÃ» modifier la mÃ©thode de classe `FormattedPrice()` qui n'Ã©tait pas fonctionnelle en l'Ã©tat afin de pouvoir l'intÃ©grer dans la vue `home.ejs`.
En effet, le prix rÃ©cupÃ©rÃ© dans la base de donnÃ©es Ã©tait de type *`string`*. Il fallait donc d'abord le convertir en nombre avant de pouvoir l'utiliser dans la vue et le formater grÃ¢ce Ã  la mÃ©thode `FormattedPrice()`.

**Mon code :**

MÃ©thode de classe fournie :

```javascript title="src/models/Coffee.js" hl_lines="21 40-48"
/**
 * Represents a Coffee product with its properties and methods.
 * The class is responsible for handling coffee data, including price formatting.
 */
class Coffee {
  #id;
  #name;
  #reference;
  #description;
  #country;
  #pricePerKg;
  #categories;
  #available;

  constructor(data) {
    this.#id = data.id;
    this.#name = data.name;
    this.#reference = data.reference;
    this.#description = data.description;
    this.#country = data.country;
    this.#pricePerKg = data.price_per_kg;
    this.#categories = data.categories;
    this.#available = data.available;
  }

  // Getters and Setters
  get id() {
    return this.#id;
  }

  get name() {
    return this.#name;
  }

  set name(value) {
    this.#name = value;
  }
  // ... And so on for other getters/setters ...

  /**
   * Formats the coffee price for display.
   * Converts the price to a fixed 2-decimal format and replaces the dot with a comma,
   * which is a common format in many European locales.
   * @returns {string} The formatted price as a string.
   */
  formattedPrice() {
    return this.#pricePerKg.toFixed(2).replace('.', ',');
  }
}

export default Coffee;
```

Refactorisation de la mÃ©thode :

```javascript title="src/models/Coffee.js" hl_lines="21-22"
/**
 * Represents a Coffee product with its properties and methods.
 * The class is responsible for handling coffee data, including price formatting.
 */
class Coffee {
  #id;
  #name;
  #reference;
  #description;
  #country;
  #pricePerKg;
  #categories;
  #available;

  constructor(data) {
    this.#id = data.id;
    this.#name = data.name;
    this.#reference = data.reference;
    this.#description = data.description;
    this.#country = data.country;
    // Refectorisation here: convert the price from string to float to ensure proper formatting
    this.#pricePerKg = parseFloat(data.price_per_kg);
    this.#categories = data.categories;
    this.#available = data.available;
  }

  // Getters and Setters
  get id() {
    return this.#id;
  }

  get name() {
    return this.#name;
  }

  set name(value) {
    this.#name = value;
  }
  // ... And so on...

  /**
   * Formats the coffee price for display.
   * Converts the price to a fixed 2-decimal format and replaces the dot with a comma,
   * which is a common format in many European locales.
   * @returns {string} The formatted price as a string.
   */
  formattedPrice() {
    return this.#pricePerKg.toFixed(2).replace('.', ',');
  }
}

export default Coffee;
```

Refactorisation de la vue `home.ejs` avec la mÃ©thode `FormattedPrice()` :

```html title="views/pages/home.ejs" hl_lines="17-19"
<!-- header -->
<main>
  <!-- Other sections -->
  <section id="latest-products">
    <h2>NouveautÃ©s</h2>

    <ul>
      <% articles.forEach(article => { %>
      <li>
        <article>
          <img
            src="/images/coffees/<%= article.reference %>.png"
            alt="<%= article.name %>"
          />
          <div>
            <h3><%= article.name %></h3>
            <!-- Paragraph added to display formatted price of an article -->
            <!-- Using formattedPrice() method from Coffee Class instance -->
            <p><%= article.formattedPrice() %></p>
            <a class="button-outline" href="/article/<%= article.id %>">
              Voir le dÃ©tail
            </a>
          </div>
        </article>
      </li>
      <% }) %>
    </ul>
  </section>
</main>
<!-- footer -->
```

**RÃ©sultat attendu :**

Le prix sâ€™affiche sous la forme `20,99 â‚¬` (au lieu dâ€™un nombre brut comme `20.99`).

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris avec ce Challenge**

1. **La POO permet dâ€™encapsuler la logique mÃ©tier** dans des classes, ce qui rend le code plus **modulaire et rÃ©utilisable**.
2. **Les mÃ©thodes comme `map()`** sont utiles pour transformer des donnÃ©es brutes en objets plus riches.
3. **Les vues deviennent plus expressives** quand elles utilisent des mÃ©thodes dâ€™objets (ex: `FormattedPrice()`).
