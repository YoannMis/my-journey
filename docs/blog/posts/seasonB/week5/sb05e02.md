---
date:
  created: 2025-12-02

draft: true
---

# **üìÖ SAISON B Semaine 5 √âpisode 2 -L‚ÄôH√©ritage et l‚ÄôArchitecture Objet ‚Äì Factoriser le Code avec `extends` et `super`**

## **üìö Notions du jour**

Aujourd'hui nous continuons √† voir les fondamentaux de la programmation orient√©e objet. Ce deuxi√®me √©pisode est d√©di√© √† l'H√©ritage et Architecture Objet.

voici les notions abord√©es aujourd‚Äôhui :

+ L‚Äôh√©ritage pour factoriser le code entre les classes.
+ Le mot-cl√© `extends` pour d√©finir une classe enfant.
+ L‚Äôop√©rateur `super()` pour appeler le constructeur parent.
+ Les membres static (m√©thodes et propri√©t√©s) qui appartiennent √† la classe elle-m√™me.
+ L‚Äôapplication de l‚Äôh√©ritage √† l‚Äôarchitecture des contr√¥leurs.

<!-- more -->

---

### **üß¨ Pourquoi l‚ÄôH√©ritage ?**

L‚Äôh√©ritage est un **pilier de la POO** qui permet de **factoriser du code** entre plusieurs classes. Au lieu de r√©√©crire la m√™me logique dans chaque classe, on peut **d√©finir une classe parente** qui contient les attributs et m√©thodes communs, puis **√©tendre cette classe** pour ajouter des fonctionnalit√©s sp√©cifiques.

**Avantages :**

‚úÖ **√âvite la duplication de code** (principe **DRY** : *Don‚Äôt Repeat Yourself*).  
‚úÖ **Facilite la maintenance** : une modification dans la classe parente se r√©percute sur toutes les classes enfants.  
‚úÖ **Am√©liore la lisibilit√©** en organisant le code de mani√®re hi√©rarchique.

---

### **üèóÔ∏è Le Mot-Cl√© `extends` : Cr√©er une Classe Enfant**

Le mot-cl√© `extends` permet de **cr√©er une classe enfant** qui **h√©rite** des attributs et m√©thodes d‚Äôune classe parente.

#### **1Ô∏è‚É£ Exemple : Une Classe Parente `BaseModel`**

```javascript title="BaseModel.js"
class BaseModel {
  // This property is common to all models
  #id;

  constructor(id) {
    this.#id = id;
  }

  // That method is common to all models
  get id() {
    return this.#id;
  }
}

export default BaseModel;
```

**Explications :**

+ `BaseModel` est une classe **g√©n√©rique** qui contient des attributs communs (`id`) et des m√©thodes pour y acc√©der.

---

#### **2Ô∏è‚É£ √âtendre la Classe `BaseModel` avec `extends` et l‚ÄôOp√©rateur `super()` pour Appeler le Constructeur Parent**

```javascript title="Coffee.js"
// First we import the parent Class to inherit from
import BaseModel from './Model.js';

// To inherit from (extend) a parent class,
// We use the keyword `extends` and reference the parent class.
class Coffee extends BaseModel {
  #name;
  #reference;
  #description;
  #country;
  #pricePerKg;
  #categories;
  #available;

  // `data` is an object that expects all the properties of the Coffee class
  constructor(data) {
    // The `super()` method allows you to pass data into the constructor of the parent class
    // Use only in the constructor
    super(data.id); // Call the parent constructor
    this.#name = data.name;
    this.#description = data.description;
    this.#country = data.country;
    this.#pricePerKg = data.price_per_kg;
    this.#categories = data.categories;
    
  }

  // Setters and Getters

  // Specific method for Coffee
  getFormattedPrice() {
    return this.#pricePerKg.toFixed(2).replace('.', ',');
  }
}

export default Coffee;
```

**Explications :**

+ `extends BaseModel` : `Coffee` h√©rite de `BaseModel`.
+ `super(id)` : Appelle le constructeur de la classe parente pour initialiser `id`.
+ `Coffee` ajoute ses propres attributs (`name`, `description`, etc.) et m√©thodes (`getFormattedPrice()`).

---

### **üèõÔ∏è Les Membres Statiques : M√©thodes et Propri√©t√©s de Classe**

Les **membres statiques** (m√©thodes ou propri√©t√©s) appartiennent √† la **classe elle-m√™me**, et non aux instances. Ils sont utiles pour :

+ D√©finir des **constantes** ou des configurations communes.
+ Cr√©er des **m√©thodes utilitaires** qui n‚Äôont pas besoin d‚Äôacc√©der aux attributs d‚Äôune instance.

#### **1Ô∏è‚É£ Propri√©t√© Statique**

Les **propri√©t√©s statiques** sont des attributs qui **appartiennent √† la classe elle-m√™me**, et non aux instances individuelles. Elles sont particuli√®rement utiles pour d√©finir des **constantes**, des **configurations globales**, ou des **valeurs partag√©es** par toutes les instances de la classe.

**Exemple avec la classe `Coffee` :**

Imaginons que nous voulons d√©finir une **valeur de TVA commune** √† appliquer sur tous les produits. Plut√¥t que de r√©p√©ter cette information dans chaque instance, nous pouvons la d√©finir comme une **propri√©t√© statique** de la classe.

```javascript title="Coffee.js" hl_lines="4-5"
import BaseModel from './Model.js';

class Coffee extends BaseModel {
  // Static property for VAT (20%)
  static VAT_RATE = 0.20;

  constructor(data) {
    super(data.id); // Call the parent constructor
    this.#name = data.name;
    this.#pricePerKg = data.price_per_kg;
    // Other properties...
  }

  // Method to calculate VAT
  getPriceWithVAT() {
    return this.#pricePerKg * (1 + Coffee.VAT_RATE); // Use of static property
  }
}

// Use
const espresso = new Coffee(1, 'Espresso', 2.50);
console.log(espresso.getPriceWithVAT()); // Display 3.00 (2.50 * 1.20)
console.log(Coffee.VAT_RATE); // Display 0.20 (direct access via the class)
```

**Pourquoi utiliser des propri√©t√©s statiques ?**

+ **√âviter la duplication** : La TVA n‚Äôa pas besoin d‚Äô√™tre stock√©e dans chaque instance.
+ **Acc√®s direct via la classe** : On peut y acc√©der avec `Coffee.VAT_RATE` sans cr√©er d‚Äôinstance.
+ **Centralisation des configurations** : Si la TVA change, il suffit de modifier la propri√©t√© statique, et toutes les instances utiliseront la nouvelle valeur.

**Cas d‚Äôusage courants :**

+ **Constantes globales** (ex: taux de TVA, cat√©gories par d√©faut).
+ **Configurations partag√©es** (ex: nom de la table en base de donn√©es).
+ **Compteurs ou registres** (ex: compter le nombre total d‚Äôinstances cr√©√©es).

---

#### **2Ô∏è‚É£ M√©thode Statique pour Cr√©er des Instances**

Les **m√©thodes statiques** sont des fonctions qui **appartiennent √† la classe elle-m√™me**, et non aux instances. Elles sont id√©ales pour :

+ **Cr√©er des utilitaires** li√©s √† la classe (ex: formater des donn√©es, valider des entr√©es).
+ **Fabriquer des instances** √† partir de donn√©es brutes (ex: convertir une ligne de base de donn√©es en objet).
+ **Effectuer des op√©rations globales** qui ne d√©pendent pas des attributs d‚Äôune instance sp√©cifique.

```javascript title="Coffee.js" hl_lines="20-30"
import datamapper from "../../database/main-datamapper.js";
import BaseModel from './Model.js';

class Coffee extends BaseModel {
  // Static property for VAT (20%)
  static VAT_RATE = 0.20;

  constructor(data) {
    super(data.id); // Call the parent constructor
    this.#name = data.name;
    this.#pricePerKg = data.price_per_kg;
    // Other properties...
  }

  // Method to calculate VAT
  getPriceWithVAT() {
    return this.#pricePerKg * (1 + Coffee.VAT_RATE); // Use of static property
  }

  // Static method via the keyword "static",
  // allows you to use the method without instantiating the Coffee class
  static async findAll() {
    const records = await datamapper.getAllAvailableProducts();

    return records.map(record => new Coffee({
      id: record.id,
      name: record.name,
      pricePerKg: record.price_per_kg,
    }));
  }
}

export default Coffee;
```

```javascript title="main-controller.js" hl_lines="9-10"
import Coffee from "../src/models/Coffee.js";

const mainController = {
  async renderCatalogPage(req, res) {
    try {
      // If there is no static method, we would have to instantiate the class to use the method
      // const coffee = new Coffee();

      // Using the static findAll() method of the Coffee class without instantiating the class
      const articles = await Coffee.findAll();
      res.render("pages/catalog", { articles });
    } catch (error) {
      console.error(error);
      res.status(500).render("pages/error");
    }
  }
}

export default mainController;
```

**Pourquoi Utiliser des M√©thodes Statiques ?**

1. **Pas besoin d‚Äôinstance** : On peut appeler `Coffee.findAll()` sans cr√©er d‚Äôobjet `Coffee` au pr√©alable.
2. **Logique centralis√©e** : Les validations ou transformations sont d√©finies **au niveau de la classe**, ce qui √©vite la duplication de code.

**Cas d‚ÄôUsage Courants :**

+ **Validations** : V√©rifier la coh√©rence des donn√©es avant de cr√©er un objet (ex: `Email.isValid(email)`).
+ **Op√©rations globales** : Calculs ou transformations qui ne d√©pendent pas d‚Äôune instance (ex: `Math.max()` en JavaScript natif).
+ **Requ√™tes sur la classe** : R√©cup√©rer toutes les instances d‚Äôun type donn√© (ex: `Coffee.findAll()`).

---

### **üí° Ce Que J‚Äôai Appris Aujourd‚Äôhui**

1. **L‚Äôh√©ritage (`extends`)** permet de **factoriser le code** entre plusieurs classes.
2. **`super()`** appelle le constructeur de la classe parente pour initialiser les attributs h√©rit√©s.
3. **Les membres statiques (`static`)** appartiennent √† la classe elle-m√™me et sont utiles pour les **constantes** ou **m√©thodes utilitaires**.

---

## **‚å®Ô∏è Challenge du jour : "Projet oCoffee" ‚Äì projet fil rouge (suite)**

---

### **‚òïÔ∏è Pr√©sentation du Challenge**

Aujourd‚Äôhui, l‚Äôobjectif √©tait de **refactoriser notre contr√¥leur principal** (`mainController`) en utilisant la **Programmation Orient√©e Objet (POO)**. Plus pr√©cis√©ment, nous devions :

+ **Cr√©er une classe de base `CoreController`** pour centraliser la logique commune (comme la gestion des erreurs 404).
+ **Transformer notre contr√¥leur existant** (`mainController`) en une classe `ProductController` qui **h√©rite** de `CoreController`.
+ **Adapter les exports et les imports** pour que tout fonctionne correctement avec Express.

**Pourquoi ?**

+ **√âviter la duplication de code** (ex: gestion des erreurs 404 dans chaque m√©thode).
+ **Centraliser la logique commune** pour faciliter la maintenance.
+ **Am√©liorer la structure du code** en utilisant l‚Äôh√©ritage.

---

### **üìå √âtapes √† R√©aliser**

#### **1Ô∏è‚É£ Cr√©er la Classe `CoreController`**

**Objectif :** D√©finir une classe de base avec une m√©thode pour g√©rer les erreurs 404.

**Mon code :**

```javascript title="src/controllers/CoreController.js"
class CoreController {
  handleError404 = (res) => {
    res.status(404).render('pages/error', {status: 404});
  };
}

export default CoreController;
```

**Explications :**

+ `handleError404()` : M√©thode pour afficher une page 404 personnalis√©e avec un message indiquant le statut 404.

---

#### **2Ô∏è‚É£ Transformer `mainController` en `ProductController`**

**Objectif :** Refactoriser l‚Äôobjet litt√©ral `mainController` en une classe `ProductController` qui h√©rite de `CoreController`.

**Mon code :**

```javascript title="src/controllers/ProductController.js"
// Import the CoreController to inherit the `handleError404()` method.
import CoreController from "./CoreController.js";
import Coffee from "../models/Coffee.js";

// Inherit the CoreController class
class ProductController extends CoreController {
  renderCoffeeDetailsPage = async (req, res) => {
    try {
      const articleId = parseInt(req.params.id);
      // Return 404 error if the id got from the route to coffee details params is not a number
      if (isNaN(articleId)) {
        // Use `handleError404()` method from CoreController
        return this.handleError404(res);
      }

      const article = await Coffee.findById(articleId);
      // Return 404 error if no Coffee is found in the database
      if (!article) {
        // Use `handleError404()` method from CoreController
        return this.handleError404(res);
      }

      // Render coffee details page
      res.render("pages/article", { article });
    } catch (error) {
      console.error(error);
      res.status(500).render("pages/error");
    }
  };
};
```

**Explications :**

+ **Fonctions fl√©ch√©es** (`renderCoffeeDetailsPage = async (...) => { ... }`) : Garantissent que `this` reste li√© √† l‚Äôinstance de la classe (n√©cessaire pour acc√©der √† `this.handleError404`).
+ **H√©ritage** : `ProductController` h√©rite de `CoreController` et utilise sa m√©thode `handleError404`.

---

#### **3Ô∏è‚É£ Exporter une Instance de `ProductController`**

**Objectif :** Exporter une **instance** de `ProductController` pour que le router puisse l‚Äôutiliser.

**Mon code :**

```javascript title="src/controllers/ProductController.js"
// src/controllers/ProductController.js
// ... (previous code)

export default new ProductController(); // Export an instance
```

**Explications :**

+ **`export default new ProductController()`** : Exporte une instance de la classe, ce qui permet √† Express d‚Äôappeler les m√©thodes directement (ex: `productController.renderCoffeeDetailsPage`).

---

#### **4Ô∏è‚É£ Mettre √† Jour le Router**

**Objectif :** Importer et utiliser l‚Äôinstance de `ProductController` dans le router.

**Mon code :**

```javascript title="src/routers/main-router.js"
import { Router } from "express";
// Import an instance of the ProductController
import productController from '../controllers/ProductController.js';

const router = Router();

router.get("/", ProductController.renderHomePage);
router.get("/catalog", ProductController.renderCatalogPage);
router.get("/article/:id", ProductController.renderCoffeeDetailsPage);

export default router;
```

**Explications :**

**`productController.renderHomePage`, `ProductController.renderCatalogPage`, `ProductController.renderCoffeeDetailsPage`** : Appellent les m√©thodes de l‚Äôinstance de `ProductController` export√©e.

---

### **üí° Ce Que J‚Äôai Appris avec ce Challenge**

1. **L‚Äôh√©ritage** permet de **factoriser la logique commune** (ex: gestion des erreurs) dans une classe parente.
2. **Les fonctions fl√©ch√©es** dans les classes pr√©servent le contexte de `this`, ce qui est crucial pour acc√©der aux m√©thodes h√©rit√©es.
3. **Exporter une instance** de la classe permet √† Express d‚Äôappeler les m√©thodes directement.
4. **La POO rend le code plus modulaire et maintenable**, surtout dans les projets de taille moyenne/grande.
