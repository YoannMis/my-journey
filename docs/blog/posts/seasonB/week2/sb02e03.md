---
date:
  created: 2025-11-14

draft: true
---

# **ğŸ“… SAISON B Semaine 2 Ã‰pisode 3 - Les Middlewares avec Express**

## **ğŸ“š Notions du jour**

Aujourdâ€™hui, jâ€™ai dÃ©couvert un concept **central** dans Express : les **middlewares**. Un middleware, câ€™est comme un **ouvrier sur une chaÃ®ne de montage** : il reÃ§oit une requÃªte, fait un travail spÃ©cifique (comme valider des donnÃ©es, logger une information, ou modifier la requÃªte/rÃ©ponse), puis passe le relais au middleware suivant. **Express est dâ€™ailleurs conÃ§u comme un moteur de middlewares** : tout y est middleware, des routes aux gestionnaires dâ€™erreurs ! C'est ce qu'on appel un *design pattern*.  
Nous utilisions dÃ©jÃ  sans le savoir des *middlewares* lors de notre apprentissage d'Express.

**Pourquoi câ€™est puissant ?**

+ **ModularitÃ©** : Chaque middleware a une responsabilitÃ© unique.
+ **RÃ©utilisabilitÃ©** : Un middleware peut Ãªtre utilisÃ© sur plusieurs routes.
+ **FlexibilitÃ©** : Vous pouvez ajouter, retirer ou rÃ©organiser des middlewares sans tout casser.

<!-- more -->

---

### **ğŸ”— Comment Fonctionnent les Middlewares ?**

Un middleware est une **fonction** qui prend **3 paramÃ¨tres** :

1. `req` : Lâ€™objet **requÃªte** (informations sur la requÃªte HTTP).
2. `res` : Lâ€™objet **rÃ©ponse** (pour envoyer une rÃ©ponse au client).
3. `next` : Une **fonction callback** pour passer au middleware suivant.

**Syntaxe de base :**

```javascript
function myMiddleware(req, res, next) {
  // Something to do with req and/or res here
  console.log("Middleware executed!");
  next(); // Go to the next middleware
}
```

---

### **ğŸ“Œ Deux FaÃ§ons dâ€™Utiliser les Middlewares**

#### **1ï¸âƒ£ Middleware SpÃ©cifique Ã  une Route (`app.get`, `app.post`, etc.)**

Le middleware **ne sâ€™exÃ©cute que si lâ€™URL correspond** Ã  la route.

**Exemple :**

```javascript
app.get('/about', (req, res, next) => {
  console.log("Someone accessed the About page!");
  next();
}, (req, res) => {
  res.send("About Page");
});
```

**Explications :**

+ Le premier argument de `app.get` est un **middleware** qui logge lâ€™accÃ¨s Ã  `/about`.
+ Le deuxiÃ¨me argument est la **fonction qui envoie la rÃ©ponse**.

---

#### **2ï¸âƒ£ Middleware Global (`app.use`)**

Le middleware **sâ€™exÃ©cute pour toutes les requÃªtes**, peu importe lâ€™URL.

**Exemple :**

```javascript
// Middleware that logs all request
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});
```

**Cas dâ€™usage :**

+ **Logging** (journalisation des requÃªtes).
+ **Authentification** (vÃ©rifier si lâ€™utilisateur est connectÃ©).

---

### **âš™ï¸ Lâ€™Ordre des Middlewares : Une Question Cruciale**

Lâ€™ordre dans lequel on **chaÃ®ne les middlewares** est **essentiel** ! Express exÃ©cute les middlewares **dans lâ€™ordre oÃ¹ ils sont dÃ©clarÃ©s**. Si un middleware **nâ€™appelle pas `next()`**, la chaÃ®ne sâ€™arrÃªte.

**Exemple :**

```javascript
// Middleware 1 : Logs the request
app.use((req, res, next) => {
  console.log("Middleware 1");
  next();
});

// Finale route
app.get('/', (req, res) => {
  res.send("Welcome!");
});
```

---

### **ğŸ› ï¸ Exemples Concrets de Middlewares**

#### **1ï¸âƒ£ Middleware de Logging**

**Objectif :** Logger toutes les requÃªtes (mÃ©thode, URL, heure).

```javascript
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});
```

#### **2ï¸âƒ£ Middleware pour Servir des Fichiers Statiques**

**Objectif :** Servir les fichiers CSS, JS et images depuis un dossier `public/`.

```javascript
app.use(express.static('public'));
```

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris Aujourdâ€™hui**

1. **Tout est middleware dans Express** : Les routes, les gestionnaires dâ€™erreurs, mÃªme `express.static`.
2. **Lâ€™ordre des middlewares est crucial** : Un middleware qui nâ€™appelle pas `next()` bloque la chaÃ®ne.
3. **Les middlewares permettent de :**
   + **Logger** les requÃªtes.
   + **Valider** les donnÃ©es (authentification, validation de formulaires).
   + **Modifier** les requÃªtes/rÃ©ponses.
   + **GÃ©rer les erreurs** de maniÃ¨re centralisÃ©e.
4. **`app.use()` vs `app.get()`** :
   + `app.use()` : Middleware **global** (toutes les requÃªtes).
   + `app.get()` : Middleware **spÃ©cifique** Ã  une route/mÃ©thode.

---

## **âŒ¨ï¸ Challenge du jour : Challenge Middlewares pour la GhibliothÃ¨que â€“ Gestion des 404 et Journalisation des Visites**

### **ğŸ¤ PrÃ©sentation du Challenge**

Aujourdâ€™hui, nous allons amÃ©liorer notre **GhibliothÃ¨que** en ajoutant deux **middlewares essentiels** :

1. **Une gestion personnalisÃ©e des erreurs 404** pour afficher une page "not found" stylisÃ©e quand une route nâ€™existe pas.
2. **Un systÃ¨me de journalisation (logging)** pour tracer les visites (date, IP, chemin accÃ©dÃ©).

Lâ€™objectif Ã©tait de **comprendre le fonctionnement des middlewares** dans Express et de les utiliser pour **amÃ©liorer lâ€™expÃ©rience utilisateur** et le **dÃ©bogage**.

---

### **ğŸ“Œ Ã‰tapes Ã  RÃ©aliser**

#### **1ï¸âƒ£ Gestion des 404 PersonnalisÃ©e**

**Objectif :** Afficher une **page 404 personnalisÃ©e** quand une route nâ€™est pas trouvÃ©e.

#### **ğŸ”§ Solution ImplÃ©mentÃ©e**

Jâ€™ai dâ€™abord eu du mal Ã  comprendre comment capturer les erreurs 404 **sans consulter la documentation** (comme demandÃ© dans lâ€™Ã©noncÃ©). AprÃ¨s quelques essais, jâ€™ai trouvÃ© une solution qui fonctionne, mais je ne suis pas sÃ»r quâ€™elle soit optimale.

**Mon code :**
*(InsÃ©rer ici ton bloc de code pour la gestion des 404. Par exemple :)*

```javascript
// index.js
import express from 'express';
import { router } from './src/routers/index.router.js';

const app = express();

// Configuration des fichiers statiques et du moteur de templates
app.use(express.static('public'));
app.set('view engine', 'ejs');
app.set('views', './src/views');

// Utilisation du router principal
app.use(router);

// Middleware pour gÃ©rer les 404 (doit Ãªtre aprÃ¨s toutes les routes)
app.use((req, res, next) => {
  // Si aucune route n'est trouvÃ©e, renvoyer une erreur 404
  res.status(404).render('404', { message: "Page non trouvÃ©e" });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

**AmÃ©lioration possible :**

Utiliser un **middleware dâ€™erreur** (`app.use((err, req, res, next) => { ... })`) pour capturer les erreurs 404 de maniÃ¨re plus Ã©lÃ©gante. Cependant, pour les routes inexistantes, le middleware ci-dessus est suffisant.

---

### **2ï¸âƒ£ Journalisation des Visites**

**Objectif :** **Logger** (journaliser) chaque requÃªte avec :

+ La **date** de la requÃªte.
+ **Lâ€™adresse IP** du visiteur.
+ Le **chemin accÃ©dÃ©** (ex: `/movies/1`).

#### **ğŸ”§ Solution ImplÃ©mentÃ©e**

Jâ€™ai explorÃ© lâ€™objet `req` pour trouver les informations nÃ©cessaires. Voici comment jâ€™ai implÃ©mentÃ© le middleware de logging :

**Mon code :**
*(InsÃ©rer ici ton bloc de code pour le middleware de journalisation. Par exemple :)*

```javascript
// Middleware de logging (Ã  placer avant les routes)
app.use((req, res, next) => {
  const date = new Date().toISOString();
  const ip = req.ip || req.connection.remoteAddress;
  const path = req.path;

  // Formatage des logs : [date-iso ip] path
  console.log(`[${date} ${ip}] ${path}`);

  next(); // Passer au middleware suivant
});
```

---

### **3ï¸âƒ£ Bonus : Formatage Ã‰lÃ©gant des Logs**

**Objectif :** AmÃ©liorer le format des logs pour quâ€™ils soient **plus lisibles et exploitables**.

#### **ğŸ”§ Solution ImplÃ©mentÃ©e**

Jâ€™ai ajustÃ© le format des logs pour quâ€™ils suivent le format demandÃ© : `[date-iso ip] path`.

**Mon code mis Ã  jour :**
*(InsÃ©rer ici ton bloc de code pour le formatage Ã©lÃ©gant des logs. Par exemple :)*

```javascript
// Middleware de logging amÃ©liorÃ©
app.use((req, res, next) => {
  const date = new Date().toISOString();
  const ip = req.ip.replace('::ffff:', '') || 'unknown'; // Nettoyer l'IP (ex: ::ffff:127.0.0.1 â†’ 127.0.0.1)
  const path = req.path;

  console.log(`[${date} ${ip}] ${path}`);
  next();
});
```

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris avec ce Challenge**

1. **Les middlewares sont le cÅ“ur dâ€™Express** : Ils permettent dâ€™ajouter des fonctionnalitÃ©s (logging, authentification, etc.) de maniÃ¨re modulaire.
2. **Lâ€™ordre des middlewares est crucial** :
   + Le middleware de logging **doit Ãªtre placÃ© avant les routes** pour capturer toutes les requÃªtes.
   + Le middleware 404 **doit Ãªtre placÃ© aprÃ¨s toutes les routes** pour Ãªtre exÃ©cutÃ© en dernier recours.
3. **Lâ€™objet `req` contient Ã©normÃ©ment informations utiles** :
   + `req.ip` : Adresse IP du visiteur.
   + `req.path` : Chemin de la requÃªte.
   + `req.method` : MÃ©thode HTTP (GET, POST, etc.).
4. **Le formatage des logs est important** :
   + Un format clair (`[date ip] path`) permet de **filtrer et analyser** les logs facilement.
