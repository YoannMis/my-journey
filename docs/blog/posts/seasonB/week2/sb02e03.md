---
date:
  created: 2025-11-14

---

# **ğŸ“… SAISON B Semaine 2 Ã‰pisode 3 - Les Middlewares avec Express**

## **ğŸ“š Notions du jour**

Aujourdâ€™hui, jâ€™ai dÃ©couvert un concept **central** dans Express : les **middlewares**. Un middleware, câ€™est comme un **ouvrier sur une chaÃ®ne de montage** : il reÃ§oit une requÃªte, fait un travail spÃ©cifique (comme valider des donnÃ©es, logger une information, ou modifier la requÃªte/rÃ©ponse), puis passe le relais au middleware suivant. **Express est dâ€™ailleurs conÃ§u comme un moteur de middlewares** : tout y est middleware, des routes aux gestionnaires dâ€™erreurs ! C'est ce qu'on appel un *design pattern*.  
Nous utilisions dÃ©jÃ  sans le savoir des *middlewares* lors de notre apprentissage d'Express.

**Pourquoi câ€™est puissant ?**

+ **ModularitÃ©** : Chaque middleware a une responsabilitÃ© unique.
+ **RÃ©utilisabilitÃ©** : Un middleware peut Ãªtre utilisÃ© sur plusieurs routes.
+ **FlexibilitÃ©** : Vous pouvez ajouter, retirer ou rÃ©organiser des middlewares sans tout casser.

<!-- more -->

---

### **ğŸ”— Comment Fonctionnent les Middlewares ?**

Un middleware est une **fonction** qui prend **3 paramÃ¨tres** :

1. `req` : Lâ€™objet **requÃªte** (informations sur la requÃªte HTTP).
2. `res` : Lâ€™objet **rÃ©ponse** (pour envoyer une rÃ©ponse au client).
3. `next` : Une **fonction callback** pour passer au middleware suivant.

**Syntaxe de base :**

```javascript
function myMiddleware(req, res, next) {
  // Something to do with req and/or res here
  console.log("Middleware executed!");
  next(); // Go to the next middleware
}
```

---

### **ğŸ“Œ Deux FaÃ§ons dâ€™Utiliser les Middlewares**

#### **1ï¸âƒ£ Middleware SpÃ©cifique Ã  une Route (`app.get`, `app.post`, etc.)**

Le middleware **ne sâ€™exÃ©cute que si lâ€™URL correspond** Ã  la route.

**Exemple :**

```javascript
app.get('/about', (req, res, next) => {
  console.log("Someone accessed the About page!");
  next();
}, (req, res) => {
  res.send("About Page");
});
```

**Explications :**

+ Le premier argument de `app.get` est un **middleware** qui logge lâ€™accÃ¨s Ã  `/about`.
+ Le deuxiÃ¨me argument est la **fonction qui envoie la rÃ©ponse**.

---

#### **2ï¸âƒ£ Middleware Global (`app.use`)**

Le middleware **sâ€™exÃ©cute pour toutes les requÃªtes**, peu importe lâ€™URL.

**Exemple :**

```javascript
// Middleware that logs all request
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});
```

**Cas dâ€™usage :**

+ **Logging** (journalisation des requÃªtes).
+ **Authentification** (vÃ©rifier si lâ€™utilisateur est connectÃ©).

---

### **âš™ï¸ Lâ€™Ordre des Middlewares : Une Question Cruciale**

Lâ€™ordre dans lequel on **chaÃ®ne les middlewares** est **essentiel** ! Express exÃ©cute les middlewares **dans lâ€™ordre oÃ¹ ils sont dÃ©clarÃ©s**. Si un middleware **nâ€™appelle pas `next()`**, la chaÃ®ne sâ€™arrÃªte.

**Exemple :**

```javascript
// Middleware 1 : Logs the request
app.use((req, res, next) => {
  console.log("Middleware 1");
  next();
});

// Finale route
app.get('/', (req, res) => {
  res.send("Welcome!");
});
```

---

### **ğŸ› ï¸ Exemples Concrets de Middlewares**

#### **1ï¸âƒ£ Middleware de Logging**

**Objectif :** Logger toutes les requÃªtes (mÃ©thode, URL, heure).

```javascript
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});
```

#### **2ï¸âƒ£ Middleware pour Servir des Fichiers Statiques**

**Objectif :** Servir les fichiers CSS, JS et images depuis un dossier `public/`.

```javascript
app.use(express.static('public'));
```

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris Aujourdâ€™hui**

1. **Tout est middleware dans Express** : Les routes, les gestionnaires dâ€™erreurs, mÃªme `express.static`.
2. **Lâ€™ordre des middlewares est crucial** : Un middleware qui nâ€™appelle pas `next()` bloque la chaÃ®ne.
3. **Les middlewares permettent de :**
   + **Logger** les requÃªtes.
   + **Valider** les donnÃ©es (authentification, validation de formulaires).
   + **Modifier** les requÃªtes/rÃ©ponses.
   + **GÃ©rer les erreurs** de maniÃ¨re centralisÃ©e.
4. **`app.use()` vs `app.get()`** :
   + `app.use()` : Middleware **global** (toutes les requÃªtes).
   + `app.get()` : Middleware **spÃ©cifique** Ã  une route/mÃ©thode.

---

## **âŒ¨ï¸ Challenge du jour : Challenge Middlewares pour la GhibliothÃ¨que â€“ Gestion des 404 et Journalisation des Visites**

### **ğŸ¤ PrÃ©sentation du Challenge**

Aujourdâ€™hui, nous allons amÃ©liorer notre **GhibliothÃ¨que** en ajoutant deux **middlewares essentiels** :

1. **Une gestion personnalisÃ©e des erreurs 404** pour afficher une page "not found" stylisÃ©e quand une route nâ€™existe pas.
2. **Un systÃ¨me de journalisation (logging)** pour tracer les visites (date, IP, chemin accÃ©dÃ©).

Lâ€™objectif Ã©tait de **comprendre le fonctionnement des middlewares** dans Express et de les utiliser pour **amÃ©liorer lâ€™expÃ©rience utilisateur** et le **dÃ©bogage**.

---

### **ğŸ“‹ Ã‰tapes Ã  RÃ©aliser**

#### **1ï¸âƒ£ Gestion des 404 PersonnalisÃ©e**

**Objectif :** Afficher une **page 404 personnalisÃ©e** quand une route nâ€™est pas trouvÃ©e.

#### **ğŸ‘¨â€ğŸ’» Solution proposÃ©e**

Jâ€™ai dâ€™abord eu du mal Ã  comprendre comment capturer les erreurs 404 **sans consulter la documentation** (comme demandÃ© dans lâ€™Ã©noncÃ©). AprÃ¨s quelques essais, jâ€™ai trouvÃ© une solution qui fonctionne, mais je ne suis pas sÃ»r quâ€™elle soit optimale. Je me suis dit que je pouvais crÃ©er un Middleware qui renvoie une *erreur 404* par dÃ©faut si aucune route n'est trouvÃ©e. PlacÃ© aprÃ¨s le Middleware qui qui gÃ¨re les routes `app.use(router);`, si aucune route n'est trouvÃ©e quand l'utilisateur essaie d'accÃ©der Ã  une url qui n'existe pas, cela renvoie un statut 404 et rend la page personalisÃ©e 404 existante.

**Mon code :**

```javascript title="index.js" hl_lines="14-18" linenums="1"
import express from 'express';
import { router } from './src/routers/index.router.js';

const app = express();

// Configuring static files and the template engine
app.use(express.static('public'));
app.set('view engine', 'ejs');
app.set('views', './src/views');

// Using the main router
app.use(router);

// Middleware to handle 404 errors (must be after all routes)
app.use((req, res, next) => {
  // If no route is found, return a 404 error
  res.status(404).render('404', { message: "Page non trouvÃ©e" });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

**RÃ©flexions aprÃ¨s avoir lu la documentation :**

AprÃ¨s avoir vÃ©rifiÃ© la documentation, il s'avÃ¨re que cette solution Ã©tait la bonne ğŸ˜…. Je cherchais Ã  forcÃ©ment capturer une erreur afin de la renvoyer. Alors que la documentation prÃ©cise que ce n'est pas nÃ©cessaire : [how to handle 404 responses](https://expressjs.com/en/starter/faq.html#how-do-i-handle-404-responses).  
ğŸ‘‰ *In Express, 404 responses are not the result of an error, so the error-handler middleware will not capture them. This behavior is because a 404 response simply indicates the absence of additional work to do; in other words, Express has executed all middleware functions and routes, and found that none of them responded. All you need to do is add a middleware function at the very bottom of the stack (below all other functions) to handle a 404 response.*

---

### **2ï¸âƒ£ Journalisation des Visites**

**Objectif :** **Logger** (journaliser) chaque requÃªte avec :

+ La **date** de la requÃªte.
+ **Lâ€™adresse IP** du visiteur.
+ Le **chemin accÃ©dÃ©** (ex: `/movies/1`).

#### **ğŸ‘¨â€ğŸ’» Solution proposÃ©e**

Jâ€™ai explorÃ© lâ€™objet `req` pour trouver les informations nÃ©cessaires. Voici comment jâ€™ai implÃ©mentÃ© le middleware de logging :

**Mon code :**

```javascript title="request-logging.middleware.js in /src/middlewares/"
export function requestLogging(req, res, next) {
  const timestamp = new Date().toISOString();
  const ipAddress = req.ip;
  const url = req.url;
  console.log(`${timestamp} ${ipAddress} ${url}`);
  next();
}
```

**Import** du middleware de logging dans `index.js` :

```javascript title="index.js" hl_lines="3 12-13" linenums="1"
import express from 'express';
import { router } from './src/routers/index.router.js';
import { requestLogging } from './src/middlewares/request-logging.middleware.js';

const app = express();

// Configuring static files and the template engine
app.use(express.static('public'));
app.set('view engine', 'ejs');
app.set('views', './src/views');

// Using the logging middleware (must be before all routes)
app.use(requestLogging);

// Using the main router
app.use(router);

// Middleware to handle 404 errors (must be after all routes)
app.use((req, res, next) => {
  // If no route is found, return a 404 error
  res.status(404).render('404', { message: "Page non trouvÃ©e" });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

---

### **3ï¸âƒ£ Bonus : Formatage Ã‰lÃ©gant des Logs**

**Objectif :** AmÃ©liorer le format des logs pour quâ€™ils soient **plus lisibles et exploitables**.

#### **ğŸ‘¨â€ğŸ’» Solution proposÃ©e**

Jâ€™ai ajustÃ© le format des logs pour quâ€™ils suivent le format demandÃ© : `[date-iso ip] path`.

**Mon code mis Ã  jour :**
*(InsÃ©rer ici ton bloc de code pour le formatage Ã©lÃ©gant des logs. Par exemple :)*

```javascript title="request-logging.middleware.js in /src/middlewares/"
export function requestLogging(req, res, next) {
  const timestamp = new Date().toISOString();
  const ipAddress = req.ip;
  const url = req.url;
  console.log(`[${timestamp} ${ipAddress}] ${url}`);
  next();
}
```

---

### **ğŸ’¡ Ce Que Jâ€™ai Appris avec ce Challenge**

1. **Les middlewares sont le cÅ“ur dâ€™Express** : Ils permettent dâ€™ajouter des fonctionnalitÃ©s (logging, authentification, etc.) de maniÃ¨re modulaire.
2. **Lâ€™ordre des middlewares est crucial** :
   + Le middleware de logging **doit Ãªtre placÃ© avant les routes** pour capturer toutes les requÃªtes.
   + Le middleware 404 **doit Ãªtre placÃ© aprÃ¨s toutes les routes** pour Ãªtre exÃ©cutÃ© en dernier recours.
3. **Lâ€™objet `req` contient Ã©normÃ©ment informations utiles** :
   + `req.ip` : Adresse IP du visiteur.
   + `req.url` : URL de la requÃªte.
   + `req.method` : MÃ©thode HTTP (GET, POST, etc.).
4. **Le formatage des logs est important** :
   + Un format clair (`[date ip] path`) permet de **filtrer et analyser** les logs facilement.
