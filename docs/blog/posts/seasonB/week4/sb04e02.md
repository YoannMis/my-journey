---
date:
  created: 2025-11-25

draft: true
---

# **üìÖ SAISON B Semaine 4 √âpisode 2 - Jointures et Agr√©gations en SQL**

## **üìö Notions du jour**

Aujourd‚Äôhui, nous avons explor√© deux concepts **puissants** en SQL : **les jointures** et **les agr√©gations**. Ces outils permettent de **lier des tables entre elles** et de **r√©sumer des donn√©es** pour en extraire des informations utiles.

Les jointures sont essentielles pour **combiner des donn√©es** issues de plusieurs tables, tandis que les agr√©gations permettent de **calculer des statistiques** (comme des comptes, des moyennes ou des sommes).

Nous avons vu :

+ **Les diff√©rents types de jointures** (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, etc.).
+ **Les fonctions d‚Äôaggr√©gation** (`COUNT`, `SUM`, `AVG`, `MIN`, `MAX`).
+ **Comment utiliser `GROUP BY` et `HAVING`** pour regrouper et filtrer des donn√©es.
+ **L‚Äôint√©gration de ces concepts dans un projet r√©el** (Trombinoclock) avec des **datamappers** et des **contr√¥leurs**.

<!-- more -->

### **üîß Les Jointures en SQL**

Les jointures permettent de **combiner des lignes de deux ou plusieurs tables** en fonction d‚Äôune relation entre certaines colonnes. Elles sont **indispensables** pour exploiter des bases de donn√©es relationnelles.

#### **1Ô∏è‚É£ Syntaxe de Base des Jointures**

```sql
SELECT *
FROM tableA
JOIN tableB ON tableA.id = tableB.tableA_id;
```

**Exemple concret :**

```sql
-- Lier les tables `promo` et `teacher` via une table de liaison `promo_has_teacher`
SELECT
  promo.*,                     -- Toutes les colonnes de la table promo
  teacher.name                 -- Seulement le nom du formateur
FROM
  promo
  JOIN promo_has_teacher       -- Table de liaison pour les associations N:N
    ON promo.id = promo_has_teacher.promo_id
  JOIN teacher                 -- Table des formateurs
    ON teacher.id = promo_has_teacher.teacher_id
WHERE
  teacher.id = 1;             -- Filtrer pour un formateur sp√©cifique
```

---

#### **2Ô∏è‚É£ Types de Jointures**

##### **a. `INNER JOIN` (Jointure Interne)**

R√©cup√®re **uniquement les lignes qui ont une correspondance** dans les deux tables.

**Exemple :**

```sql
-- Employ√©s et leurs d√©partements (seulement ceux qui ont un d√©partement)
SELECT e.first_name, d.name
FROM employee e
INNER JOIN department d ON e.department_id = d.id;
```

**R√©sultat :**

| first_name | name          |
|------------|---------------|
| Alice      | Informatique  |
| Bob        | Informatique  |
| Charlie    | Ressources Humaines |

---

##### **b. `LEFT JOIN` (Jointure √† Gauche)**

R√©cup√®re **toutes les lignes de la table de gauche** (premi√®re table), m√™me si elles n‚Äôont pas de correspondance dans la table de droite.

**Exemple :**

```sql
-- Tous les employ√©s, m√™me ceux sans d√©partement
SELECT e.first_name, d.name
FROM employee e
LEFT JOIN department d ON e.department_id = d.id;
```

**R√©sultat :**

| first_name | name          |
|------------|---------------|
| Alice      | Informatique  |
| Bob        | Informatique  |
| Charlie    | Ressources Humaines |
| David      | NULL          |  -- Employ√© sans d√©partement

---

##### **c. `RIGHT JOIN` (Jointure √† Droite)**

R√©cup√®re **toutes les lignes de la table de droite** (deuxi√®me table), m√™me si elles n‚Äôont pas de correspondance dans la table de gauche.

**Exemple :**

```sql
-- Tous les d√©partements, m√™me ceux sans employ√©s
SELECT e.first_name, d.name
FROM employee e
RIGHT JOIN department d ON e.department_id = d.id;
```

**R√©sultat :**

| first_name | name          |
|------------|---------------|
| Alice      | Informatique  |
| Bob        | Informatique  |
| Charlie    | Ressources Humaines |
| NULL       | Marketing     |  -- D√©partement sans employ√©

---

##### **d. `FULL JOIN` (Jointure Compl√®te)**

R√©cup√®re **toutes les lignes des deux tables**, avec des valeurs `NULL` pour les correspondances manquantes.

**Exemple :**

```sql
-- Tous les employ√©s et tous les d√©partements
SELECT e.first_name, d.name
FROM employee e
FULL JOIN department d ON e.department_id = d.id;
```

**R√©sultat :**

| first_name | name          |
|------------|---------------|
| Alice      | Informatique  |
| Bob        | Informatique  |
| Charlie    | Ressources Humaines |
| David      | NULL          |  -- Employ√© sans d√©partement
| NULL       | Marketing     |  -- D√©partement sans employ√©

---

##### **e. `CROSS JOIN` (Produit Cart√©sien)**

G√©n√®re **toutes les combinaisons possibles** entre les deux tables (produit cart√©sien).

**Exemple :**

```sql
-- Toutes les combinaisons employ√©-d√©partement
SELECT e.first_name, d.name
FROM employee e
CROSS JOIN department d;
```

**R√©sultat :**

| first_name | name          |
|------------|---------------|
| Alice      | Informatique  |
| Alice      | Ressources Humaines |
| Alice      | Marketing     |
| Bob        | Informatique  |
| ...        | ...           |

---

### **üìä Les Agr√©gations en SQL**

Les **fonctions d‚Äôaggr√©gation** permettent de **calculer une valeur unique** √† partir d‚Äôun ensemble de lignes. Elles sont souvent utilis√©es avec `GROUP BY` pour regrouper les donn√©es par cat√©gories.

#### **1Ô∏è‚É£ Fonctions d‚ÄôAgr√©gation Principales**

##### **a. `COUNT()` ‚Äì Compter les Lignes**

```sql
-- Compter le nombre total de formateurs
SELECT COUNT(*) FROM teacher;

-- Compter les formateurs avec un nom non-null
SELECT COUNT(name) FROM teacher;

-- Compter les valeurs distinctes
SELECT COUNT(DISTINCT github_organisation) FROM promo;
```

**Exemple :**

```sql
-- Table promo
-- { id: 1, name: 'Francfort - Front', github_organisation: 'https://github.com/O-clock-Francfort' },
-- { id: 2, name: 'Francfort - Back', github_organisation: 'https://github.com/O-clock-Francfort' }
SELECT COUNT(id) FROM promo; -- ‚Üí 2
SELECT COUNT(DISTINCT github_organisation) FROM promo; -- ‚Üí 1
```

---

##### **b. `SUM()` ‚Äì Additionner les Valeurs**

```sql
-- Somme totale des salaires (si la colonne existait)
SELECT SUM(salary) FROM teacher;
```

---

##### **c. `AVG()` ‚Äì Calculer la Moyenne**

```sql
-- Salaire moyen des formateurs
SELECT AVG(salary) FROM teacher;
```

---

##### **d. `MIN()` et `MAX()` ‚Äì Trouver les Valeurs Minimales et Maximales**

```sql
-- Salaire minimum et maximum
SELECT MIN(salary), MAX(salary) FROM teacher;

-- Premier et dernier nom dans l'ordre alphab√©tique
SELECT MIN(name), MAX(name) FROM teacher;
```

---

#### **2Ô∏è‚É£ Utiliser `GROUP BY` pour Regrouper les Donn√©es**

`GROUP BY` permet de **regrouper les lignes** qui ont la m√™me valeur dans une colonne sp√©cifi√©e, puis d‚Äôappliquer des fonctions d‚Äôaggr√©gation sur chaque groupe.

**Exemple :**

```sql
-- Nombre de formateurs par promo
SELECT promo_id, COUNT(*) as nb_teachers
FROM promo_has_teacher
GROUP BY promo_id;

-- Nombre de promos par formateur
SELECT teacher_id, COUNT(*) as nb_promos
FROM promo_has_teacher
GROUP BY teacher_id;
```

---

#### **3Ô∏è‚É£ Filtrer les Groupes avec `HAVING`**

`HAVING` permet de **filtrer les r√©sultats apr√®s agr√©gation**, contrairement √† `WHERE` qui filtre avant.

**Exemple :**

```sql
-- Les promos ayant plus de 2 formateurs
SELECT promo_id, COUNT(*) as nb_teachers
FROM promo_has_teacher
GROUP BY promo_id
HAVING COUNT(*) >= 2;

-- Les formateurs assign√©s √† au moins 2 promos
SELECT teacher_id, COUNT(*) as nb_promos
FROM promo_has_teacher
GROUP BY teacher_id
HAVING COUNT(*) >= 2;
```

**Remarque :**

+ `WHERE` filtre **avant** l‚Äôaggr√©gation.
+ `HAVING` filtre **apr√®s** l‚Äôaggr√©gation.

---

### **üîÑ Exemple Complet : Jointures + Agr√©gations**

**Objectif :** Afficher le nom des formateurs et le nombre de promos auxquelles ils sont associ√©s.

```sql
SELECT
  t.name,
  COUNT(pht.promo_id) as nombre_de_promos
FROM teacher t
LEFT JOIN promo_has_teacher pht ON t.id = pht.teacher_id
GROUP BY t.id, t.name
ORDER BY nombre_de_promos DESC;
```

**R√©sultat :**

| name          | nombre_de_promos |
|---------------|------------------|
| John Doe      | 3                |
| Jane Smith    | 2                |
| Bob Johnson   | 1                |

---

### **üí° Fonctions JSON en PostgreSQL**

PostgreSQL offre des **fonctions puissantes** pour manipuler des donn√©es au format JSON directement dans les requ√™tes SQL.

#### **1Ô∏è‚É£ `json_agg()` ‚Äì Agr√©gat en Tableau JSON**

Transforme un ensemble de lignes en un **tableau JSON**.

**Exemple :**

```sql
-- Tableau des IDs des formateurs
SELECT json_agg(id) FROM teacher;
-- R√©sultat : [1, 2, 3, 4, ...]

-- Tableau des noms des promos pour chaque formateur
SELECT
  teacher.*,
  json_agg(
    json_build_object(
      'id', promo.id,
      'name', promo.name
    )
  ) as promos
FROM
  teacher
  JOIN promo_has_teacher ON teacher.id = promo_has_teacher.teacher_id
  JOIN promo ON promo_has_teacher.promo_id = promo.id
GROUP BY
  teacher.id
ORDER BY
  teacher.id ASC;
```

**R√©sultat :**

```json
{
  "id": 1,
  "name": "John Doe",
  "promos": [
    {"id": 558, "name": "Tesla"},
    {"id": 746, "name": "Li√©geois"}
  ]
}
```

---

#### **2Ô∏è‚É£ `json_object_agg()` ‚Äì Cr√©er un Objet JSON**

Transforme un ensemble de lignes en un **objet JSON** avec des paires cl√©-valeur.

**Exemple :**

```sql
-- Objet avec cl√©=ID et valeur=name
SELECT json_object_agg(id, name) FROM teacher;
-- R√©sultat : {"1": "John Doe", "2": "Jane Smith", ...}

-- Objet des promos pour chaque formateur
SELECT
  teacher.*,
  json_object_agg(promo.id, promo.name) AS promos
FROM
  teacher
  JOIN promo_has_teacher ON teacher.id = promo_has_teacher.teacher_id
  JOIN promo ON promo_has_teacher.promo_id = promo.id
GROUP BY
  teacher.id
ORDER BY
  teacher.id ASC;
```

**R√©sultat :**

```json
{
  "1": "Tesla",
  "2": "Li√©geois"
}
```

---

#### **3Ô∏è‚É£ Combinaison de Fonctions JSON**

```sql
SELECT
  json_build_object(
    'id', t.id,
    'name', t.name,
    'promos', json_agg(
      json_build_object(
        'id', p.id,
        'name', p.name
      )
    )
  ) as teacher
FROM teacher t
LEFT JOIN promo_has_teacher pht ON t.id = pht.teacher_id
LEFT JOIN promo p ON pht.promo_id = p.id
GROUP BY t.id, t.name
ORDER BY t.id;
```

**R√©sultat :**

```json
{
  "id": 1,
  "name": "John Doe",
  "promos": [
    {"id": 558, "name": "Tesla"},
    {"id": 746, "name": "Li√©geois"}
  ]
}
```

---

### **üìÅ Mise en Pratique dans Trombinoclock**

#### **1Ô∏è‚É£ Router et Contr√¥leur pour Afficher les Formateurs et Leurs Promos**

**Objectif :** Cr√©er une route `/teachers` pour afficher la liste des formateurs avec leurs promos.

**Router (`routers/teacher.router.js`):**

```javascript
import { Router } from 'express';
import { listTeachers } from '../controllers/teacher.controller.js';

const router = Router();

router.get('/', listTeachers);

export default router;
```

---

#### **2Ô∏è‚É£ Contr√¥leur pour Pr√©parer les Donn√©es**

**Objectif :** R√©cup√©rer les formateurs et leurs promos, puis pr√©parer les donn√©es pour la vue.

**Contr√¥leur (`controllers/teacher.controller.js`):**

```javascript
import { findTeachersWithPromos } from '../datamappers/teacher.datamapper.js';

export async function listTeachers(req, res) {
  try {
    const data = await findTeachersWithPromos();
    const teachers = [];

    // Regrouper les promos par formateur
    for (const row of data) {
      const existingTeacher = teachers.find((t) => t.id === row.id);

      if (!existingTeacher) {
        teachers.push({
          id: row.id,
          name: row.name,
          promos: [{ id: row.promo_id, name: row.promo_name }]
        });
      } else {
        existingTeacher.promos.push({ id: row.promo_id, name: row.promo_name });
      }
    }

    res.render('teacher/liste', { teachers });
  } catch (error) {
    console.error(error);
    res.status(500).send("Erreur serveur");
  }
}
```

---

#### **3Ô∏è‚É£ DataMapper pour R√©cup√©rer les Donn√©es**

**Objectif :** Ex√©cuter une requ√™te SQL pour r√©cup√©rer les formateurs et leurs promos.

**DataMapper (`datamappers/teacher.datamapper.js`):**

```javascript
export async function findTeachersWithPromos() {
  const query = `
    SELECT
      teacher.*,                                        -- All teacher info
      promo.id AS promo_id, promo.name AS promo_name   -- Only needed promo info
    FROM
      teacher
      LEFT JOIN promo_has_teacher                       -- Use LEFT JOIN to include teachers without promos
        ON teacher.id = promo_has_teacher.teacher_id
      LEFT JOIN promo
        ON promo_has_teacher.promo_id = promo.id
    ORDER BY
      teacher.id ASC
  `;

  const results = await client.query(query);
  return results.rows;
}
```

**Pourquoi `LEFT JOIN` ?**

+ `INNER JOIN` exclut les formateurs **sans promo**.
+ `LEFT JOIN` inclut **tous les formateurs**, m√™me ceux sans promo.

---

#### **4Ô∏è‚É£ Vue pour Afficher les R√©sultats**

**Objectif :** Afficher la liste des formateurs et leurs promos dans une vue EJS.

**Vue (`views/teacher/liste.ejs`):**

```html
<%- include('partials/header') %>
<h1>Liste des Formateurs</h1>
<ul class="cards">
  <% for(const teacher of teachers) { %>
  <li class="card card--label">
    <h2><%= teacher.name %></h2>
    <p>Promos:</p>
    <ul>
      <% for(const promo of teacher.promos) { %>
      <li>
        <a href="/promo/<%= promo.id %>/students">
          <%= promo.name %>
        </a>
      </li>
      <% } %>
    </ul>
  </li>
  <% } %>
</ul>
<%- include('partials/footer') %>
```

---

### **üí° Ce Que J‚Äôai Appris Aujourd‚Äôhui**

1. **Les jointures** permettent de **combiner des donn√©es** issues de plusieurs tables.
   + `INNER JOIN` : Seulement les correspondances.
   + `LEFT JOIN` : Toutes les lignes de la table de gauche.
   + `RIGHT JOIN` : Toutes les lignes de la table de droite.
   + `FULL JOIN` : Toutes les lignes des deux tables.
2. **Les agr√©gations** (`COUNT`, `SUM`, `AVG`, etc.) permettent de **r√©sumer des donn√©es**.
   + `GROUP BY` regroupe les lignes par cat√©gories.
   + `HAVING` filtre les groupes apr√®s agr√©gation.
3. **Les fonctions JSON** de PostgreSQL (`json_agg`, `json_object_agg`) sont **puissantes** pour formater des r√©sultats complexes.
4. **L‚Äôint√©gration dans un projet r√©el** (Trombinoclock) montre comment utiliser ces concepts pour **afficher des donn√©es li√©es** (formateurs et promos).
