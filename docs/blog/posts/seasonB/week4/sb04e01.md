---
date:
  created: 2025-11-24

draft: true
---

# **ğŸ“… SAISON B Semaine 4 Ã‰pisode 1 - Les Associations en Bases de DonnÃ©es â€“ Lier les EntitÃ©s avec SQL**

## **ğŸ“š Notions du jour**

Aujourdâ€™hui, nous avons explorÃ© un concept **fondamental** en bases de donnÃ©es : **les associations entre entitÃ©s**. Que ce soit pour lier des Ã©tudiants Ã  leurs promotions, des professeurs Ã  leurs cours, ou des articles Ã  leurs catÃ©gories, les associations permettent de **modÃ©liser des relations complexes** dans une base de donnÃ©es relationnelle.

Nous avons vu :

+ **Les types dâ€™associations** (1:1, 1:N, N:N).
+ **Comment les implÃ©menter** dans une base de donnÃ©es SQL.
+ **Comment interroger ces associations** avec des requÃªtes `SELECT` et `JOIN`.

<!-- more -->

### **ğŸ“š Vocabulaire : CardinalitÃ©**

La **cardinalitÃ©** dÃ©crit le **nombre de liens** entre deux entitÃ©s. Elle peut Ãªtre :

+ **0:1** : ZÃ©ro ou un (ex. : un Ã©tudiant peut avoir zÃ©ro ou un casier).
+ **1:1** : Un et un seul (ex. : un Ã©tudiant a un seul prÃ©nom).
+ **0:N** : ZÃ©ro ou plusieurs (ex. : un Ã©tudiant peut avoir zÃ©ro ou plusieurs notes).
+ **1:N** : Un ou plusieurs (ex. : une promotion a un ou plusieurs Ã©tudiants).
+ **N:N** : Plusieurs Ã  plusieurs (ex. : un professeur peut enseigner dans plusieurs promotions, et une promotion peut avoir plusieurs professeurs).

---

### **ğŸ”§ Types dâ€™Associations et Leur ImplÃ©mentation**

---

#### **2ï¸âƒ£ Association 1:N | One to Many**

**Exemple** : Une promotion concerne **plusieurs Ã©tudiants**.

**ImplÃ©mentation** :

Ajouter une colonne `promo_id` dans la table des Ã©tudiants (cÃ´tÃ© "N") pour faire rÃ©fÃ©rence Ã  la table des promotions (cÃ´tÃ© "1").

**Tables :**

```sql
-- Table des promotions
CREATE TABLE promo (
  id INT PRIMARY KEY,
  name VARCHAR(50) NOT NULL
);

-- Table des Ã©tudiants avec une clÃ© Ã©trangÃ¨re vers 'promo'
CREATE TABLE student (
  id INT PRIMARY KEY,
  last_name VARCHAR(50) NOT NULL,
  promo_id INT,
  FOREIGN KEY (promo_id) REFERENCES promo(id)  -- ClÃ© Ã©trangÃ¨re pour lier Ã  'promo'
);
```

**Exemple de donnÃ©es :**

**Table `promo` :**

| id  | name   |
|:---:|:------:|
| 93  | Zenith |

**Table `student` :**

| id  | last_name | promo_id |
|:---:|:--------:|:--------:|
| 0   | Dupont   | 93       |
| 1   | Dubois   | 93       |

---

#### **3ï¸âƒ£ Association N:N | Many to Many**

**Exemple** : Plusieurs professeurs enseignent dans plusieurs promotions.

**ImplÃ©mentation** :

CrÃ©er une **table de liaison** (ou table dâ€™association) qui contient les clÃ©s Ã©trangÃ¨res des deux tables.

**Tables :**

```sql
-- Table des professeurs
CREATE TABLE teacher (
  id INT PRIMARY KEY,
  first_name VARCHAR(50) NOT NULL
  last_name VARCHAR(50) NOT NULL
);

-- Table des promotions
CREATE TABLE promo (
  id INT PRIMARY KEY,
  name VARCHAR(50) NOT NULL
);

-- Table de liaison entre professeurs et promotions
CREATE TABLE teacher_has_promo (
  teacher_id INT,
  promo_id INT,
  PRIMARY KEY (teacher_id, promo_id),  -- ClÃ© primaire composite
  FOREIGN KEY (teacher_id) REFERENCES teacher(id),
  FOREIGN KEY (promo_id) REFERENCES promo(id)
);
```

**Exemple de donnÃ©es :**

**Table `teacher` :**

| id  | first_name | last_name |
|:---:|:----------:|:---------:|
| 1   | Simon      | Dujardin  |
| 2   | Yann       | Elrik     |

**Table `promo` :**

| id  | name   |
|:---:|:------:|
| 93  | Zenith |
| 94  | Asgard |

**Table `teacher_has_promo` :**

| teacher_id | promo_id |
|:----------:|:--------:|
| 1          | 93       |
| 2          | 93       |
| 2          | 94       |

**ReprÃ©sentation visuelle :**

|                 | Simon | Yann |
|:---------------:|:-----:|:----:|
| **Zenith (93)** | X     | X    |
| **Asgard (94)** |       | X    |

---

### **ğŸ” RequÃªtes SQL avec Associations**

#### **1ï¸âƒ£ RequÃªte Simple avec `SELECT` et `FROM`**

Pour rÃ©cupÃ©rer des donnÃ©es de **plusieurs tables sans jointure explicite**, on peut lister les tables dans le `FROM`. Cependant, cela gÃ©nÃ¨re un **produit cartÃ©sien** (toutes les combinaisons possibles), ce qui est rarement utile sans filtre.

**Exemple :**

```sql
-- RÃ©cupÃ¨re toutes les combinaisons d'Ã©tudiants et de promotions (peu utile sans WHERE)
SELECT student.lastname, promo.name
FROM student, promo;
```

**RÃ©sultat (produit cartÃ©sien) :**

| lastname | name   |
|:--------:|:------:|
| Dupont   | Zenith |
| Dupont   | Asgard |
| Dubois   | Zenith |
| Dubois   | Asgard |

---

#### **2ï¸âƒ£ RequÃªtes avec `JOIN`**

Les **jointures** (`JOIN`) permettent de lier des tables en fonction dâ€™une condition (gÃ©nÃ©ralement une Ã©galitÃ© entre clÃ©s Ã©trangÃ¨res).

##### **a. Jointure Interne (`INNER JOIN`)**

RÃ©cupÃ¨re **uniquement les lignes qui ont une correspondance** dans les deux tables.

**Exemple :**

```sql
-- RÃ©cupÃ¨re les Ã©tudiants avec leur promotion
SELECT student.last_name, promo.name
FROM student
INNER JOIN promo ON student.promo_id = promo.id;
```

**RÃ©sultat :**

| last_name | name   |
|:---------:|:------:|
| Dupont    | Zenith |
| Dubois    | Zenith |

---

##### **b. Jointure Externe (`LEFT JOIN`, `RIGHT JOIN`)**

+ **`LEFT JOIN`** : RÃ©cupÃ¨re **toutes les lignes de la table de gauche**, mÃªme si elles nâ€™ont pas de correspondance dans la table de droite.
+ **`RIGHT JOIN`** : RÃ©cupÃ¨re **toutes les lignes de la table de droite**, mÃªme si elles nâ€™ont pas de correspondance dans la table de gauche.

**Exemple avec `LEFT JOIN` :**

```sql
-- RÃ©cupÃ¨re tous les Ã©tudiants, mÃªme ceux sans promotion
SELECT student.last_name, promo.name
FROM student
LEFT JOIN promo ON student.promo_id = promo.id;
```

**RÃ©sultat :**

| last_name | name   |
|:---------:|:------:|
| Dupont    | Zenith |
| Dubois    | Zenith |
| Martin    | NULL   |  # Ã‰tudiant sans promotion

---

##### **c. Jointure pour les Associations N:N**

Pour les associations **N:N**, on utilise la **table de liaison** dans le `JOIN`.

**Exemple :**

```sql
-- RÃ©cupÃ¨re les professeurs et leurs promotions
SELECT teacher.first_name, teacher.last_name, promo.name
FROM teacher
INNER JOIN teacher_promo ON teacher.id = teacher_promo.teacher_id  -- On fait le lien entre la table de liaison `teacher_promo` et la table `teacher`
INNER JOIN promo ON teacher_promo.promo_id = promo.id;  -- On fait le lien entre la table de liaison `teacher_promo` et la table `promo`
```

**RÃ©sultat :**

| first_name | last_name | name   |
|:----------:|:---------:|--------|
| Simon      | Dujardin  | Zenith |
| Yann       | Elrik     | Zenith |
| Yann       | Elrik     | Asgard |

---

### **ğŸ’¡ RÃ©sumÃ© des Associations et Jointures**

| Type dâ€™Association | ImplÃ©mentation                     | RequÃªte SQL Exemple                                                 |
|:------------------:|:----------------------------------:|:-------------------------------------------------------------------:|
| 1:1                | Ajouter une colonne                | `SELECT * FROM student`                                             |
| 1:N                | ClÃ© Ã©trangÃ¨re cÃ´tÃ© "N"             | `SELECT * FROM student JOIN promo ON ...`                           |
| N:N                | Table de liaison                   | `SELECT * FROM teacher JOIN teacher_promo ON ... JOIN promo ON ...` |

---

### **ğŸš€ Ce Que Jâ€™ai Appris Aujourdâ€™hui**

1. **Les associations** permettent de modÃ©liser des relations entre entitÃ©s (1:1, 1:N, N:N).
2. **ImplÃ©mentation** :
   + **1:N** : Ajouter une clÃ© Ã©trangÃ¨re cÃ´tÃ© "N".
   + **N:N** : CrÃ©er une table de liaison.
3. **RequÃªtes SQL** :
   + `JOIN` permet de lier des tables de maniÃ¨re efficace.
   + `INNER JOIN` pour les correspondances exactes.
   + `LEFT JOIN` ou `RIGHT JOIN` pour inclure les lignes sans correspondance.

---

## **âŒ¨ï¸ Challenge du jour : Qui a DÃ©tournÃ© O'clock ? Un Challenge Type "Cluedo" avec des Jointures !**

---

### **ğŸ•µï¸â€â™‚ï¸ PrÃ©sentation du Challenge**

Aujourdâ€™hui, jâ€™ai relevÃ© un dÃ©fi **ludique et technique** : rÃ©soudre une enquÃªte faÃ§on "Cluedo" en utilisant **uniquement des requÃªtes SQL** ! Lâ€™objectif Ã©tait de retrouver le coupable dâ€™un dÃ©tournement de photos parmi les Ã©tudiants dâ€™Oâ€™clock, en fouillant dans une base de donnÃ©es qui contenait des **tÃ©moignages, rapports de police, et informations sur les personnes impliquÃ©es**.

**ScÃ©nario :**

Un Ã©tudiant mal intentionnÃ© a crÃ©Ã© des photomontages caricaturaux avec les tÃªtes de membres de lâ€™Ã©quipe. La police a rÃ©digÃ© un rapport, et des tÃ©moins ont donnÃ© des indices. Notre mission : **retrouver le coupable** en utilisant des **requÃªtes SQL avec jointures**.

**Indice de dÃ©part :**

+ Un **rapport de police** datÃ© du **11 dÃ©cembre 2019**, Ã©tiquetÃ© **"caricature abusive"**.

---

### **ğŸ“Œ Ã‰tapes de lâ€™EnquÃªte et RequÃªtes SQL que j'ai rÃ©alisÃ©**

#### **1ï¸âƒ£ Inspecter les Tables de la Base de DonnÃ©es**

**Objectif :** Identifier les tables disponibles pour savoir oÃ¹ chercher les indices.

**Ma requÃªte :**

```sql
SHOW TABLES;
```

**RÃ©sultat :**

| Tables_in_cluedo |
|:----------------:|
| personne         |
| projet           |
| promo            |
| rapport_police   |
| role             |
| temoignage       |

---

#### **2ï¸âƒ£ Comprendre le Format des Dates dans `rapport_police`**

**Objectif :** VÃ©rifier le format des dates pour Ã©crire la requÃªte correctement.

**Ma requÃªte :**

```sql
SELECT date FROM rapport_police;
```

**RÃ©sultat :**

| date     |
|:--------:|
| 08122019 |
| 25122019 |
| 03122019 |
| 10122019 |
| ...      |

**Observation :**

Les dates sont au format `JJMMAAAA` (ex: `11122019` pour le 11 dÃ©cembre 2019).

---

#### **3ï¸âƒ£ Trouver le Rapport de Police**

**Objectif :** RÃ©cupÃ©rer le rapport du **11/12/2019** avec le type **"caricature abusive"**.

**Ma requÃªte :**

```sql
SELECT * FROM rapport_police
WHERE date = '11122019' AND type = 'caricature abusive';
```

**RÃ©sultat :**

| id | date     | type               | rapport                                                                                                                                                                          |
|:--:|:--------:|:------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| 44 | 11122019 | caricature abusive | Des membres d'Oclock ont subi des caricatures abusives. Nous avons deux tÃ©moins : une certaine Beth Rave ainsi que la personne habitant au dernier numÃ©ro de la rue Sadi Carnot. |

**Indices obtenus :**

1. **Beth Rave** a un tÃ©moignage.
2. Une personne habitant au **dernier numÃ©ro de la rue Sadi Carnot** a aussi un tÃ©moignage.

---

#### **4ï¸âƒ£ Trouver le TÃ©moignage de Beth Rave**

**Objectif :** RÃ©cupÃ©rer le tÃ©moignage de **Beth Rave** pour avoir plus dâ€™indices.

**Ma requÃªte :**

```sql
SELECT nom, temoignage FROM temoignage
INNER JOIN personne ON temoignage.personne_id = personne.id
WHERE personne.nom = 'Beth Rave';
```

**RÃ©sultat :**

| nom       | temoignage                                                                        |
|-----------|-----------------------------------------------------------------------------------|
| Beth Rave | Je n'ai pas vu le coupable, mais il faisait partie de la promo de couleur pourpre. |

**Indice clÃ© :**
Le coupable fait partie dâ€™une promo de **couleur pourpre**.

---

#### **5ï¸âƒ£ Trouver la Personne au Dernier NumÃ©ro de la Rue Sadi Carnot**

**Objectif :** Identifier la personne habitant au **dernier numÃ©ro de la rue Sadi Carnot**.

**Ma requÃªte :**

```sql
SELECT *
FROM personne
WHERE rue ILIKE '%sadi carno'
ORDER BY numero_rue DESC
LIMIT 1;
```

**RÃ©sultat :**

| id   | nom          | rue             | numero_rue | age | taille | promo_id | projet_id | role_id |
|:----:|:------------:|:---------------:|:----------:|:---:|:------:|:--------:|:---------:|:-------:|
| 549  | Alex TrÃ©mitÃ© | rue Sadi Carnot | 995        | 52  | 153    | 9        | 36        | 1       |

---

#### **6ï¸âƒ£ Trouver le TÃ©moignage dâ€™Alex TrÃ©mitÃ©**

**Objectif :** RÃ©cupÃ©rer le tÃ©moignage dâ€™**Alex TrÃ©mitÃ©** pour plus dâ€™indices.

**Ma requÃªte :**

```sql
SELECT nom, temoignage FROM temoignage
INNER JOIN personne ON temoignage.personne_id = personne.id
WHERE personne.id = 549;
```

**RÃ©sultat :**

| nom          | temoignage                                                                                                         |
|:------------:|:------------------------------------------------------------------------------------------------------------------:|
| Alex TrÃ©mitÃ© | J'ai vu le coupable mais je ne connais pas son nom ! En revanche, je sais qu'il a travaillÃ© sur le projet O'asis ! |

**Indice clÃ© :**

Le coupable a travaillÃ© sur le projet **"O'asis"**.

---

#### **7ï¸âƒ£ Trouver le Coupable avec les Indices CumulÃ©s**

**Objectif :** Trouver la personne qui :

1. Fait partie dâ€™une promo de **couleur pourpre**.
2. A travaillÃ© sur le projet **"O'asis"**.

**Ma requÃªte :**

```sql
SELECT nom, promo_id, nom_promo, couleur, projet_id, nom_projet
FROM personne
INNER JOIN promo ON personne.promo_id = promo.id
INNER JOIN projet ON personne.projet_id = projet.id
WHERE couleur = 'pourpre' AND nom_projet = 'O''asis';
```

**RÃ©sultat :**

| nom          | promo_id | nom_promo | couleur  | projet_id | nom_projet |
|:------------:|:--------:|:---------:|:--------:|:---------:|:----------:|
| Cyril Hique  | 20       | Tardis    | pourpre  | 15        | O'asis     |

**Premier coupable trouvÃ© :**

**Cyril Hique** est lâ€™auteur des caricatures, mais il avoue avoir agi **sur ordre de quelquâ€™un dâ€™autre** !

---

#### **8ï¸âƒ£ Trouver le TÃ©moignage de Cyril Hique**

**Objectif :** DÃ©couvrir qui a commanditÃ© les dÃ©tournements.

**Ma requÃªte :**

```sql
SELECT nom, temoignage FROM temoignage
JOIN personne ON temoignage.personne_id = personne.id
WHERE personne.nom = 'Cyril Hique';
```

**RÃ©sultat :**

| nom         | temoignage                                                                                                                                                  |
|:-----------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Cyril Hique | C'est bien moi qui ai fait les caricatures mais Ã  la demande de quelqu'un de l'Ã©quipe. C'est un helper qui a entre 40 et 45 ans et fait entre 1m80 et 1m90. |

**Nouveaux indices :**

+ Le vrai coupable est un **helper**.
+ Ã‚ge : **entre 40 et 45 ans**.
+ Taille : **entre 1m80 et 1m90**.

---

#### **9ï¸âƒ£ Trouver le Vrai Coupable**

**Objectif :** Identifier le **helper** correspondant aux critÃ¨res dâ€™Ã¢ge et de taille.

**Ma requÃªte :**

```sql
SELECT nom, nom_role, age, taille
FROM role
INNER JOIN personne ON role.id = personne.role_id
WHERE nom_role ILIKE 'helper'
AND age >= 40 AND age <= 45
AND taille >= 180 AND taille <= 190;
```

**RÃ©sultat :**

| nom                       | nom_role | age | taille |
|:-------------------------:|:--------:|:---:|:------:|
| GÃ©dÃ©on Groidenmabaignoire | Helper   | 44  | 186    |

**Coupable final :**

**GÃ©dÃ©on Groidenmabaignoire** est le **cerveau** derriÃ¨re les dÃ©tournements !

---

### **ğŸ¯ Ce Que Jâ€™ai Appris avec ce Challenge**

1. **Les jointures (`INNER JOIN`) sont puissantes** pour relier des tables et trouver des informations croisÃ©es.
2. **Les requÃªtes SQL peuvent Ãªtre enchaÃ®nÃ©es** pour affiner les rÃ©sultats (ex: utiliser un `id` trouvÃ© dans une requÃªte pour en lancer une autre).
3. **Les indices dans les bases de donnÃ©es** sont souvent **cachÃ©s dans les relations** entre tables (ex: tÃ©moignages liÃ©s Ã  des personnes, projets liÃ©s Ã  des Ã©tudiants).
4. **La logique dâ€™enquÃªte** : Comme dans un vrai "Cluedo", il faut **recouper les indices** pour avancer pas Ã  pas.
5. **Les requÃªtes SQL avec `WHERE` et `ORDER BY`** permettent de **filtrer et trier** les donnÃ©es pour trouver des informations prÃ©cises (ex: dernier numÃ©ro de rue, plage dâ€™Ã¢ge).
