---
date:
  created: 2025-10-16
  
draft: true
---

# **📅 SAISON A Semaine 5 Épisode 4 - Module et boucles alternatives**

## **📚 Notions du jour**

+ Correction atelier pair-programming
+ Module
+ Découpage de code
+ Event.taget, event.currentTarget

<!-- more -->

---

## **🔧 Correction de l’Atelier : La Solution de l’Enseignant**

Aujourd’hui, nous avons **revisité l’atelier de pair-programming** de la veille avec notre enseignant. L’objectif ? **Comprendre sa solution** pour créer l’ardoise pixel art et identifier les **bonnes pratiques** que nous avions (ou pas) appliquées.

**Points clés de sa solution :**

1. **Un JavaScript plus modulaire** : Le code était découpé en **fonctions claires et réutilisables**, chacune avec une responsabilité unique.
2. **Une palette de couleurs mieux gérée** : Une seule couleur sélectionnable à la fois, grâce à une logique de désélection automatique.

---

## **🧩 Découper le Code en Modules**

Nous avons vu aujourd'hui **l’importance de découper son code en modules**. Jusqu’ici, tout notre JavaScript était dans un seul fichier. Au final un code **long, difficile à maintenir et à réutiliser**.

### **Pourquoi Découper son Code ?**

1. **Lisibilité** : Des fichiers plus courts = plus faciles à comprendre.
2. **Maintenabilité** : Modifier une petite partie sans casser le reste.
3. **Réutilisabilité** : Utiliser le même module dans plusieurs projets.
4. **Collaboration** : Travailler à plusieurs sur des parties distinctes sans conflits.
5. **Performance** : Charger seulement le code nécessaire.

---

### **📦 Mise en Pratique : `import` et `export`**

Nous avons appris à **structurer notre code en modules** et à les lier avec `import` et `export`. Voici comment nous avons réorganisé notre projet :

#### **1. Structure des Fichiers**

```bash
📁 js/
├── 📁 modules/
│   ├── grid.js        # Gestion de la grille
│   ├── palette.js     # Gestion de la palette de couleurs
│   ├── form.js        # Gestion du formulaire
│   └── pixel.js       # Gestion des pixels
├── main.js            # Point d'entrée principal
└── index.html
```

#### **2. Exemple de Module : `grid.js`**

Ce module gère **uniquement la création et la mise à jour de la grille**.

```javascript title="grid.js" hl_lines="3-5"
// modules/form.js
// ...
export function generateGrid(gridSize = 8, pixelSize = 48) {
  // Function content
}
// ...
```

#### **Le fichier `main.js` importe les modules et les utilise.**

```javascript title="main.js"
// main.js
// Import all needed function from modules to start the app 
import { generateGrid } from "./modules/grid.js";
import { setupForm } from "./modules/form.js";
import { createColorPalette } from "./modules/palette.js";

// Start the app by calling functions from modules
// Generates grid
generateGrid();

// Sets up the form
setupForm();

// Creates the palette
createColorPalette();
```

---

### **🛠 Outils et Bonnes Pratiques**

+ **Nommage des fichiers** : Utiliser des noms explicites (`grid.js`, `palette.js`).
+ **Export nommés** : Préférer `export function maFonction()` pour plus de clarté.
+ **Imports groupés** : Dans `main.js`, tout est importé au début du fichier.
+ **Documentation** : Ajouter des commentaires pour expliquer le rôle de chaque module.

---

### **💡 Amélioration qui a retenu mon attention**

La fonçon dont il a fait pour régénérer une nouvelle grille sans avoir à parcourir tous les éléments de la grille => meilleure performance et optimisation.
Lors de la soumission du formulaire j'avais fait en sorte de réinitialiser la grille avant d'en générer une nouvelle avec les nouvelles valeurs récupérées dans le formulaire.
Le prblème dans ma solution ? Je récupère tous les pixels de la grille dans un tableau que je parcours pour effacer tous les pixels 1 par 1. Pas très optimisé.

Voici comment j'avais procédé :

```js title="app.js - Reset grid" hl_lines="5 6"
// ...
// Reset the grid
  const pixelsToRemove = document.querySelectorAll('.pixel'); // Get all pixels from the grid
  // Remove pixels
  for (const pixel of pixelsToRemove) {
    pixel.remove();
  }
// ...
```

Et voici la solution proposé par l'enseignant :

```js title="Teacher solution" hl_lines="5"
// ...
// Reset the grid
const pixelGrid = document.querySelector("#grid"); // Get the grid
// Remove pixels
pixelGrid.textContent = "";
// ...
```

Plutôt simple et efficace 🙃 ! Plus besoin de parcourir tout le tableau. On écrase la grille actuelle pour la remplacer par une grille vierge.

---

## **🧩 `event.taget`, `event.currentTarget`**

**Une gestion des événements optimisée** : Utilisation de la **délégation d’événements** pour éviter d’ajouter un écouteur à chaque pixel (ce qui améliore les performances).

**Exemple de délégation d’événements (pour les pixels) :**

```javascript
// Au lieu d'ajouter un écouteur à chaque pixel...
document.querySelector("#grid").addEventListener("click", (event) => {
  if (event.target.classList.contains("pixel")) {
    // Applique la couleur sélectionnée au pixel cliqué
    event.target.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");
    event.target.classList.add(selectedColor);
  }
});
```

**Avantage :** Un seul écouteur pour toute la grille, même si elle est regénérée !

---

### **🎯 Ce Que J’ai Appris Aujourd’hui**

1. **Le découpage modulaire est essentiel** pour écrire du code **propre et maintenable**.
2. **`import`/`export` sont des outils puissants** pour organiser son projet.
3. **La délégation d’événements** améliore les performances et simplifie le code.
4. **Un bon nommage** (fichiers, fonctions, variables) facilite la compréhension.
5. **La collaboration est plus fluide** quand le code est bien structuré.
