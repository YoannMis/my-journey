---
date:
  created: 2025-10-16
  
draft: true
---

# **ğŸ“… SAISON A Semaine 5 Ã‰pisode 4 - Module et boucles alternatives**

## **ğŸ“š Notions du jour**

+ Correction atelier pair-programming
+ Module
+ DÃ©coupage de code
+ Event.taget, event.currentTarget

<!-- more -->

---

## **ğŸ”§ Correction de lâ€™Atelier : La Solution de lâ€™Enseignant**

Aujourdâ€™hui, nous avons **revisitÃ© lâ€™atelier de pair-programming** de la veille avec notre enseignant. Lâ€™objectif ? **Comprendre sa solution** pour crÃ©er lâ€™ardoise pixel art et identifier les **bonnes pratiques** que nous avions (ou pas) appliquÃ©es.

**Points clÃ©s de sa solution :**

1. **Un JavaScript plus modulaire** : Le code Ã©tait dÃ©coupÃ© en **fonctions claires et rÃ©utilisables**, chacune avec une responsabilitÃ© unique.
2. **Une palette de couleurs mieux gÃ©rÃ©e** : Une seule couleur sÃ©lectionnable Ã  la fois, grÃ¢ce Ã  une logique de dÃ©sÃ©lection automatique.

---

## **ğŸ§© DÃ©couper le Code en Modules**

Nous avons vu aujourd'hui **lâ€™importance de dÃ©couper son code en modules**. Jusquâ€™ici, tout notre JavaScript Ã©tait dans un seul fichier. Au final un code **long, difficile Ã  maintenir et Ã  rÃ©utiliser**.

### **Pourquoi DÃ©couper son Code ?**

1. **LisibilitÃ©** : Des fichiers plus courts = plus faciles Ã  comprendre.
2. **MaintenabilitÃ©** : Modifier une petite partie sans casser le reste.
3. **RÃ©utilisabilitÃ©** : Utiliser le mÃªme module dans plusieurs projets.
4. **Collaboration** : Travailler Ã  plusieurs sur des parties distinctes sans conflits.
5. **Performance** : Charger seulement le code nÃ©cessaire.

---

### **ğŸ“¦ Mise en Pratique : `import` et `export`**

Nous avons appris Ã  **structurer notre code en modules** et Ã  les lier avec `import` et `export`. Voici comment nous avons rÃ©organisÃ© notre projet :

#### **1. Structure des Fichiers**

```bash
ğŸ“ js/
â”œâ”€â”€ ğŸ“ modules/
â”‚   â”œâ”€â”€ grid.js        # Gestion de la grille
â”‚   â”œâ”€â”€ palette.js     # Gestion de la palette de couleurs
â”‚   â”œâ”€â”€ form.js        # Gestion du formulaire
â”‚   â””â”€â”€ pixel.js       # Gestion des pixels
â”œâ”€â”€ main.js            # Point d'entrÃ©e principal
â””â”€â”€ index.html
```

#### **2. Exemple de Module : `grid.js`**

Ce module gÃ¨re **uniquement la crÃ©ation et la mise Ã  jour de la grille**.

```javascript title="grid.js" hl_lines="3-5"
// modules/form.js
// ...
export function generateGrid(gridSize = 8, pixelSize = 48) {
  // Function content
}
// ...
```

#### **Le fichier `main.js` importe les modules et les utilise.**

```javascript title="main.js"
// main.js
// Import all needed function from modules to start the app 
import { generateGrid } from "./modules/grid.js";
import { setupForm } from "./modules/form.js";
import { createColorPalette } from "./modules/palette.js";

// Start the app by calling functions from modules
// Generates grid
generateGrid();

// Sets up the form
setupForm();

// Creates the palette
createColorPalette();
```

---

### **ğŸ›  Outils et Bonnes Pratiques**

+ **Nommage des fichiers** : Utiliser des noms explicites (`grid.js`, `palette.js`).
+ **Export nommÃ©s** : PrÃ©fÃ©rer `export function maFonction()` pour plus de clartÃ©.
+ **Imports groupÃ©s** : Dans `main.js`, tout est importÃ© au dÃ©but du fichier.
+ **Documentation** : Ajouter des commentaires pour expliquer le rÃ´le de chaque module.

---

### **ğŸ’¡ AmÃ©lioration qui a retenu mon attention**

La fonÃ§on dont il a fait pour rÃ©gÃ©nÃ©rer une nouvelle grille sans avoir Ã  parcourir tous les Ã©lÃ©ments de la grille => meilleure performance et optimisation.
Lors de la soumission du formulaire j'avais fait en sorte de rÃ©initialiser la grille avant d'en gÃ©nÃ©rer une nouvelle avec les nouvelles valeurs rÃ©cupÃ©rÃ©es dans le formulaire.
Le prblÃ¨me dans ma solution ? Je rÃ©cupÃ¨re tous les pixels de la grille dans un tableau que je parcours pour effacer tous les pixels 1 par 1. Pas trÃ¨s optimisÃ©.

Voici comment j'avais procÃ©dÃ© :

```js title="app.js - Reset grid" hl_lines="5 6"
// ...
// Reset the grid
  const pixelsToRemove = document.querySelectorAll('.pixel'); // Get all pixels from the grid
  // Remove pixels
  for (const pixel of pixelsToRemove) {
    pixel.remove();
  }
// ...
```

Et voici la solution proposÃ© par l'enseignant :

```js title="Teacher solution" hl_lines="5"
// ...
// Reset the grid
const pixelGrid = document.querySelector("#grid"); // Get the grid
// Remove pixels
pixelGrid.textContent = "";
// ...
```

PlutÃ´t simple et efficace ğŸ™ƒ ! Plus besoin de parcourir tout le tableau. On Ã©crase la grille actuelle pour la remplacer par une grille vierge.

---

## **ğŸ§© `event.taget`, `event.currentTarget`**

**Une gestion des Ã©vÃ©nements optimisÃ©e** : Utilisation de la **dÃ©lÃ©gation dâ€™Ã©vÃ©nements** pour Ã©viter dâ€™ajouter un Ã©couteur Ã  chaque pixel (ce qui amÃ©liore les performances).

**Exemple de dÃ©lÃ©gation dâ€™Ã©vÃ©nements (pour les pixels) :**

```javascript
// Au lieu d'ajouter un Ã©couteur Ã  chaque pixel...
document.querySelector("#grid").addEventListener("click", (event) => {
  if (event.target.classList.contains("pixel")) {
    // Applique la couleur sÃ©lectionnÃ©e au pixel cliquÃ©
    event.target.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");
    event.target.classList.add(selectedColor);
  }
});
```

**Avantage :** Un seul Ã©couteur pour toute la grille, mÃªme si elle est regÃ©nÃ©rÃ©e !

---

### **ğŸ¯ Ce Que Jâ€™ai Appris Aujourdâ€™hui**

1. **Le dÃ©coupage modulaire est essentiel** pour Ã©crire du code **propre et maintenable**.
2. **`import`/`export` sont des outils puissants** pour organiser son projet.
3. **La dÃ©lÃ©gation dâ€™Ã©vÃ©nements** amÃ©liore les performances et simplifie le code.
4. **Un bon nommage** (fichiers, fonctions, variables) facilite la comprÃ©hension.
5. **La collaboration est plus fluide** quand le code est bien structurÃ©.
