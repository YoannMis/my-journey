---
date:
  created: 2025-10-16
  
draft: true
---

# **📅 SAISON A Semaine 5 Épisode 4 - Module et boucles alternatives**

## **📚 Notions du jour**

Aujourd’hui, j’ai participé à un **atelier en pair programming** avec un objectif ambitieux : créer une **application web d’ardoise pixel art**, inspirée du style rétro de *Space Invaders*. Le défi ? **Tout générer en JavaScript** : la grille de pixels, le formulaire de configuration, et même la palette de couleurs. Nous avions seulement une maquette comme point de départ. Pas de code fourni, juste une idée à concrétiser !

<!-- more -->

---

**📝 Journal Dev : Découpage Modulaire en JavaScript – Quand le Code Devient (Enfin) Organisé !**

---

### **🔧 Correction de l’Atelier : La Solution de l’Enseignant**
Aujourd’hui, nous avons **revisité l’atelier de pair programming** de la veille avec notre enseignant. L’objectif ? **Comprendre sa solution** pour créer l’ardoise pixel art et identifier les **bonnes pratiques** que nous avions (ou pas) appliquées.

**Points clés de sa solution :**
1. **Une structure HTML plus épurée** : Moins de `<div>` superflues, des classes mieux nommées.
2. **Un JavaScript plus modulaire** : Le code était découpé en **fonctions claires et réutilisables**, chacune avec une responsabilité unique.
3. **Une gestion des événements optimisée** : Utilisation de la **délégation d’événements** pour éviter d’ajouter un écouteur à chaque pixel (ce qui améliore les performances).
4. **Une palette de couleurs mieux gérée** : Une seule couleur sélectionnable à la fois, grâce à une logique de désélection automatique.

**Exemple de délégation d’événements (pour les pixels) :**
```javascript
// Au lieu d'ajouter un écouteur à chaque pixel...
document.querySelector("#grid").addEventListener("click", (event) => {
  if (event.target.classList.contains("pixel")) {
    // Applique la couleur sélectionnée au pixel cliqué
    event.target.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");
    event.target.classList.add(selectedColor);
  }
});
```
**Avantage :** Un seul écouteur pour toute la grille, même si elle est regénérée !

---

### **🧩 Notion du Jour : Découper le Code en Modules**
La grande révélation de la journée : **l’importance de découper son code en modules**. Jusqu’ici, tout notre JavaScript était dans un seul fichier. Résultat ? Un code **long, difficile à maintenir et à réutiliser**.

#### **Pourquoi Découper son Code ?**
1. **Lisibilité** : Des fichiers plus courts = plus faciles à comprendre.
2. **Maintenabilité** : Modifier une petite partie sans casser le reste.
3. **Réutilisabilité** : Utiliser le même module dans plusieurs projets.
4. **Collaboration** : Travailler à plusieurs sur des parties distinctes sans conflits.
5. **Performance** : Charger seulement le code nécessaire (avec des outils comme Webpack ou Vite).

---

### **📦 Mise en Pratique : `import` et `export`**
Nous avons appris à **structurer notre code en modules** et à les lier avec `import` et `export`. Voici comment nous avons réorganisé notre projet :

#### **1. Structure des Fichiers**
```
📁 src/
├── 📁 modules/
│   ├── grid.js        # Gestion de la grille
│   ├── palette.js     # Gestion de la palette de couleurs
│   ├── form.js        # Gestion du formulaire
│   └── utils.js       # Fonctions utilitaires
├── main.js            # Point d'entrée principal
└── index.html
```

#### **2. Exemple de Module : `grid.js`**
Ce module gère **uniquement la création et la mise à jour de la grille**.

```javascript
// grid.js
// Fonction pour générer la grille
export function generateGrid(gridSize, pixelSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = "";
  gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;

  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey");
    pixel.style.width = `${pixelSize}px`;
    pixel.style.height = `${pixelSize}px`;
    gridContainer.appendChild(pixel);
  }
}

// Fonction pour mettre à jour la couleur d'un pixel
export function updatePixelColor(pixel, color) {
  pixel.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");
  pixel.classList.add(color);
}
```

#### **3. Exemple de Module : `palette.js`**
Ce module gère **uniquement la palette de couleurs**.

```javascript
// palette.js
const colors = ["red", "blue", "green", "yellow", "purple"];
let selectedColor = "dark";

// Génère la palette
export function generatePalette() {
  const palette = document.querySelector("#palette");
  colors.forEach(color => {
    const colorDot = document.createElement("div");
    colorDot.classList.add("color-dot", color);
    colorDot.style.backgroundColor = color;
    palette.appendChild(colorDot);

    colorDot.addEventListener("click", () => {
      // Désélectionne toutes les pastilles
      document.querySelectorAll(".color-dot").forEach(dot => {
        dot.classList.remove("color-selected");
      });
      // Sélectionne la pastille cliquée
      colorDot.classList.add("color-selected");
      selectedColor = color;
    });
  });
}

// Retourne la couleur sélectionnée
export function getSelectedColor() {
  return selectedColor;
}
```

#### **4. Fichier Principal : `main.js`**
Le fichier `main.js` **import les modules** et les utilise.

```javascript
// main.js
import { generateGrid, updatePixelColor } from './modules/grid.js';
import { generatePalette, getSelectedColor } from './modules/palette.js';
import { setupForm } from './modules/form.js';

// Initialise l'application
function init() {
  generatePalette();
  setupForm(generateGrid);

  // Délégation d'événements pour la grille
  document.querySelector("#grid").addEventListener("click", (event) => {
    if (event.target.classList.contains("pixel")) {
      updatePixelColor(event.target, getSelectedColor());
    }
  });
}

init();
```

#### **5. Module `form.js`**
Gère **uniquement le formulaire**.

```javascript
// form.js
export function setupForm(generateGridCallback) {
  const form = document.querySelector("#grid-form");
  form.addEventListener("submit", (event) => {
    event.preventDefault();
    const gridSize = document.querySelector("#grid-size").value;
    const pixelSize = document.querySelector("#pixel-size").value || 50;
    generateGridCallback(parseInt(gridSize), parseInt(pixelSize));
  });
}
```

---

### **💡 Avantages Concrets du Découpage Modulaire**
1. **Clarté** :
   - Chaque fichier a une **responsabilité unique** (principe *Single Responsibility*).
   - Exemple : `grid.js` ne gère que la grille, `palette.js` que les couleurs.

2. **Réutilisabilité** :
   - Les fonctions `generateGrid` ou `generatePalette` peuvent être réutilisées dans d’autres projets.

3. **Testabilité** :
   - Tester un petit module est plus simple que tester un gros fichier.

4. **Collaboration** :
   - En équipe, chacun peut travailler sur un module différent sans risque de conflits.

5. **Évolutivité** :
   - Ajouter une nouvelle fonctionnalité (ex: sauvegarder le dessin) ne nécessite de modifier qu’un seul module.

---

### **🛠 Outils et Bonnes Pratiques**
- **Nommage des fichiers** : Utiliser des noms explicites (`grid.js`, `palette.js`).
- **Export nommés** : Préférer `export function maFonction()` pour plus de clarté.
- **Imports groupés** : Dans `main.js`, tout est importé au début du fichier.
- **Documentation** : Ajouter des commentaires pour expliquer le rôle de chaque module.

**Exemple de commentaire utile :**
```javascript
/**
 * Génère une grille de pixels de taille `gridSize x gridSize`.
 * @param {number} gridSize - Taille de la grille (ex: 16 pour 16x16).
 * @param {number} pixelSize - Taille des pixels en pixels (ex: 50).
 */
export function generateGrid(gridSize, pixelSize) {
  // ...
}
```

---

### **🎯 Ce Que J’ai Appris Aujourd’hui**
1. **Le découpage modulaire est essentiel** pour écrire du code **propre et maintenable**.
2. **`import`/`export` sont des outils puissants** pour organiser son projet.
3. **La délégation d’événements** améliore les performances et simplifie le code.
4. **Un bon nommage** (fichiers, fonctions, variables) facilite la compréhension.
5. **La collaboration est plus fluide** quand le code est bien structuré.

---
### **🚀 Prochaine Étape**
Demain, nous allons **ajouter la sauvegarde des dessins** (en localStorage) et peut-être **importer/exporter des créations** en JSON. Et bien sûr, continuer à **améliorer la modularité** de notre code !

**Et vous, comment organisez-vous vos projets JavaScript ? Avez-vous des astuces pour découper votre code ?** 😊