---
date:
  created: 2025-10-16
  
draft: true
---

# **ğŸ“… SAISON A Semaine 5 Ã‰pisode 4 - Module et boucles alternatives**

## **ğŸ“š Notions du jour**

Aujourdâ€™hui, jâ€™ai participÃ© Ã  un **atelier en pair programming** avec un objectif ambitieux : crÃ©er une **application web dâ€™ardoise pixel art**, inspirÃ©e du style rÃ©tro de *Space Invaders*. Le dÃ©fi ? **Tout gÃ©nÃ©rer en JavaScript** : la grille de pixels, le formulaire de configuration, et mÃªme la palette de couleurs. Nous avions seulement une maquette comme point de dÃ©part. Pas de code fourni, juste une idÃ©e Ã  concrÃ©tiser !

<!-- more -->

---

**ğŸ“ Journal Dev : DÃ©coupage Modulaire en JavaScript â€“ Quand le Code Devient (Enfin) OrganisÃ© !**

---

### **ğŸ”§ Correction de lâ€™Atelier : La Solution de lâ€™Enseignant**
Aujourdâ€™hui, nous avons **revisitÃ© lâ€™atelier de pair programming** de la veille avec notre enseignant. Lâ€™objectif ? **Comprendre sa solution** pour crÃ©er lâ€™ardoise pixel art et identifier les **bonnes pratiques** que nous avions (ou pas) appliquÃ©es.

**Points clÃ©s de sa solution :**
1. **Une structure HTML plus Ã©purÃ©e** : Moins de `<div>` superflues, des classes mieux nommÃ©es.
2. **Un JavaScript plus modulaire** : Le code Ã©tait dÃ©coupÃ© en **fonctions claires et rÃ©utilisables**, chacune avec une responsabilitÃ© unique.
3. **Une gestion des Ã©vÃ©nements optimisÃ©e** : Utilisation de la **dÃ©lÃ©gation dâ€™Ã©vÃ©nements** pour Ã©viter dâ€™ajouter un Ã©couteur Ã  chaque pixel (ce qui amÃ©liore les performances).
4. **Une palette de couleurs mieux gÃ©rÃ©e** : Une seule couleur sÃ©lectionnable Ã  la fois, grÃ¢ce Ã  une logique de dÃ©sÃ©lection automatique.

**Exemple de dÃ©lÃ©gation dâ€™Ã©vÃ©nements (pour les pixels) :**
```javascript
// Au lieu d'ajouter un Ã©couteur Ã  chaque pixel...
document.querySelector("#grid").addEventListener("click", (event) => {
  if (event.target.classList.contains("pixel")) {
    // Applique la couleur sÃ©lectionnÃ©e au pixel cliquÃ©
    event.target.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");
    event.target.classList.add(selectedColor);
  }
});
```
**Avantage :** Un seul Ã©couteur pour toute la grille, mÃªme si elle est regÃ©nÃ©rÃ©e !

---

### **ğŸ§© Notion du Jour : DÃ©couper le Code en Modules**
La grande rÃ©vÃ©lation de la journÃ©e : **lâ€™importance de dÃ©couper son code en modules**. Jusquâ€™ici, tout notre JavaScript Ã©tait dans un seul fichier. RÃ©sultat ? Un code **long, difficile Ã  maintenir et Ã  rÃ©utiliser**.

#### **Pourquoi DÃ©couper son Code ?**
1. **LisibilitÃ©** : Des fichiers plus courts = plus faciles Ã  comprendre.
2. **MaintenabilitÃ©** : Modifier une petite partie sans casser le reste.
3. **RÃ©utilisabilitÃ©** : Utiliser le mÃªme module dans plusieurs projets.
4. **Collaboration** : Travailler Ã  plusieurs sur des parties distinctes sans conflits.
5. **Performance** : Charger seulement le code nÃ©cessaire (avec des outils comme Webpack ou Vite).

---

### **ğŸ“¦ Mise en Pratique : `import` et `export`**
Nous avons appris Ã  **structurer notre code en modules** et Ã  les lier avec `import` et `export`. Voici comment nous avons rÃ©organisÃ© notre projet :

#### **1. Structure des Fichiers**
```
ğŸ“ src/
â”œâ”€â”€ ğŸ“ modules/
â”‚   â”œâ”€â”€ grid.js        # Gestion de la grille
â”‚   â”œâ”€â”€ palette.js     # Gestion de la palette de couleurs
â”‚   â”œâ”€â”€ form.js        # Gestion du formulaire
â”‚   â””â”€â”€ utils.js       # Fonctions utilitaires
â”œâ”€â”€ main.js            # Point d'entrÃ©e principal
â””â”€â”€ index.html
```

#### **2. Exemple de Module : `grid.js`**
Ce module gÃ¨re **uniquement la crÃ©ation et la mise Ã  jour de la grille**.

```javascript
// grid.js
// Fonction pour gÃ©nÃ©rer la grille
export function generateGrid(gridSize, pixelSize) {
  const gridContainer = document.querySelector("#grid");
  gridContainer.innerHTML = "";
  gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${pixelSize}px)`;

  for (let i = 0; i < gridSize * gridSize; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel", "grey");
    pixel.style.width = `${pixelSize}px`;
    pixel.style.height = `${pixelSize}px`;
    gridContainer.appendChild(pixel);
  }
}

// Fonction pour mettre Ã  jour la couleur d'un pixel
export function updatePixelColor(pixel, color) {
  pixel.classList.remove("grey", "dark", "red", "blue", "green", "yellow", "purple");
  pixel.classList.add(color);
}
```

#### **3. Exemple de Module : `palette.js`**
Ce module gÃ¨re **uniquement la palette de couleurs**.

```javascript
// palette.js
const colors = ["red", "blue", "green", "yellow", "purple"];
let selectedColor = "dark";

// GÃ©nÃ¨re la palette
export function generatePalette() {
  const palette = document.querySelector("#palette");
  colors.forEach(color => {
    const colorDot = document.createElement("div");
    colorDot.classList.add("color-dot", color);
    colorDot.style.backgroundColor = color;
    palette.appendChild(colorDot);

    colorDot.addEventListener("click", () => {
      // DÃ©sÃ©lectionne toutes les pastilles
      document.querySelectorAll(".color-dot").forEach(dot => {
        dot.classList.remove("color-selected");
      });
      // SÃ©lectionne la pastille cliquÃ©e
      colorDot.classList.add("color-selected");
      selectedColor = color;
    });
  });
}

// Retourne la couleur sÃ©lectionnÃ©e
export function getSelectedColor() {
  return selectedColor;
}
```

#### **4. Fichier Principal : `main.js`**
Le fichier `main.js` **import les modules** et les utilise.

```javascript
// main.js
import { generateGrid, updatePixelColor } from './modules/grid.js';
import { generatePalette, getSelectedColor } from './modules/palette.js';
import { setupForm } from './modules/form.js';

// Initialise l'application
function init() {
  generatePalette();
  setupForm(generateGrid);

  // DÃ©lÃ©gation d'Ã©vÃ©nements pour la grille
  document.querySelector("#grid").addEventListener("click", (event) => {
    if (event.target.classList.contains("pixel")) {
      updatePixelColor(event.target, getSelectedColor());
    }
  });
}

init();
```

#### **5. Module `form.js`**
GÃ¨re **uniquement le formulaire**.

```javascript
// form.js
export function setupForm(generateGridCallback) {
  const form = document.querySelector("#grid-form");
  form.addEventListener("submit", (event) => {
    event.preventDefault();
    const gridSize = document.querySelector("#grid-size").value;
    const pixelSize = document.querySelector("#pixel-size").value || 50;
    generateGridCallback(parseInt(gridSize), parseInt(pixelSize));
  });
}
```

---

### **ğŸ’¡ Avantages Concrets du DÃ©coupage Modulaire**
1. **ClartÃ©** :
   - Chaque fichier a une **responsabilitÃ© unique** (principe *Single Responsibility*).
   - Exemple : `grid.js` ne gÃ¨re que la grille, `palette.js` que les couleurs.

2. **RÃ©utilisabilitÃ©** :
   - Les fonctions `generateGrid` ou `generatePalette` peuvent Ãªtre rÃ©utilisÃ©es dans dâ€™autres projets.

3. **TestabilitÃ©** :
   - Tester un petit module est plus simple que tester un gros fichier.

4. **Collaboration** :
   - En Ã©quipe, chacun peut travailler sur un module diffÃ©rent sans risque de conflits.

5. **Ã‰volutivitÃ©** :
   - Ajouter une nouvelle fonctionnalitÃ© (ex: sauvegarder le dessin) ne nÃ©cessite de modifier quâ€™un seul module.

---

### **ğŸ›  Outils et Bonnes Pratiques**
- **Nommage des fichiers** : Utiliser des noms explicites (`grid.js`, `palette.js`).
- **Export nommÃ©s** : PrÃ©fÃ©rer `export function maFonction()` pour plus de clartÃ©.
- **Imports groupÃ©s** : Dans `main.js`, tout est importÃ© au dÃ©but du fichier.
- **Documentation** : Ajouter des commentaires pour expliquer le rÃ´le de chaque module.

**Exemple de commentaire utile :**
```javascript
/**
 * GÃ©nÃ¨re une grille de pixels de taille `gridSize x gridSize`.
 * @param {number} gridSize - Taille de la grille (ex: 16 pour 16x16).
 * @param {number} pixelSize - Taille des pixels en pixels (ex: 50).
 */
export function generateGrid(gridSize, pixelSize) {
  // ...
}
```

---

### **ğŸ¯ Ce Que Jâ€™ai Appris Aujourdâ€™hui**
1. **Le dÃ©coupage modulaire est essentiel** pour Ã©crire du code **propre et maintenable**.
2. **`import`/`export` sont des outils puissants** pour organiser son projet.
3. **La dÃ©lÃ©gation dâ€™Ã©vÃ©nements** amÃ©liore les performances et simplifie le code.
4. **Un bon nommage** (fichiers, fonctions, variables) facilite la comprÃ©hension.
5. **La collaboration est plus fluide** quand le code est bien structurÃ©.

---
### **ğŸš€ Prochaine Ã‰tape**
Demain, nous allons **ajouter la sauvegarde des dessins** (en localStorage) et peut-Ãªtre **importer/exporter des crÃ©ations** en JSON. Et bien sÃ»r, continuer Ã  **amÃ©liorer la modularitÃ©** de notre code !

**Et vous, comment organisez-vous vos projets JavaScript ? Avez-vous des astuces pour dÃ©couper votre code ?** ğŸ˜Š